var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
import MqttImpl from "mqtt/dist/mqtt";
import msgpack5 from "msgpack5/dist/msgpack5";
function _isPlaceholder(a) {
  return a != null && typeof a === "object" && a["@@functional/placeholder"] === true;
}
function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
}
function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return _isPlaceholder(a) ? f2 : _curry1(function(_b) {
          return fn(a, _b);
        });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function(_a) {
          return fn(_a, b);
        }) : _isPlaceholder(b) ? _curry1(function(_b) {
          return fn(a, _b);
        }) : fn(a, b);
    }
  };
}
function _arity(n, fn) {
  switch (n) {
    case 0:
      return function() {
        return fn.apply(this, arguments);
      };
    case 1:
      return function(a0) {
        return fn.apply(this, arguments);
      };
    case 2:
      return function(a0, a1) {
        return fn.apply(this, arguments);
      };
    case 3:
      return function(a0, a1, a2) {
        return fn.apply(this, arguments);
      };
    case 4:
      return function(a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };
    case 5:
      return function(a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };
    case 6:
      return function(a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };
    case 7:
      return function(a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };
    case 8:
      return function(a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };
    case 9:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };
    case 10:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };
    default:
      throw new Error("First argument to _arity must be a non-negative integer no greater than ten");
  }
}
function _curry3(fn) {
  return function f3(a, b, c) {
    switch (arguments.length) {
      case 0:
        return f3;
      case 1:
        return _isPlaceholder(a) ? f3 : _curry2(function(_b, _c) {
          return fn(a, _b, _c);
        });
      case 2:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function(_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) ? _curry2(function(_b, _c) {
          return fn(a, _b, _c);
        }) : _curry1(function(_c) {
          return fn(a, b, _c);
        });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function(_a, _b) {
          return fn(_a, _b, c);
        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function(_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function(_b, _c) {
          return fn(a, _b, _c);
        }) : _isPlaceholder(a) ? _curry1(function(_a) {
          return fn(_a, b, c);
        }) : _isPlaceholder(b) ? _curry1(function(_b) {
          return fn(a, _b, c);
        }) : _isPlaceholder(c) ? _curry1(function(_c) {
          return fn(a, b, _c);
        }) : fn(a, b, c);
    }
  };
}
var _isArray = Array.isArray || function _isArray2(val) {
  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === "[object Array]";
};
function _isString(x) {
  return Object.prototype.toString.call(x) === "[object String]";
}
var _isArrayLike = /* @__PURE__ */ _curry1(function isArrayLike(x) {
  if (_isArray(x)) {
    return true;
  }
  if (!x) {
    return false;
  }
  if (typeof x !== "object") {
    return false;
  }
  if (_isString(x)) {
    return false;
  }
  if (x.nodeType === 1) {
    return !!x.length;
  }
  if (x.length === 0) {
    return true;
  }
  if (x.length > 0) {
    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
  }
  return false;
});
var _isArrayLike$1 = _isArrayLike;
var XWrap = /* @__PURE__ */ function() {
  function XWrap2(fn) {
    this.f = fn;
  }
  XWrap2.prototype["@@transducer/init"] = function() {
    throw new Error("init not implemented on XWrap");
  };
  XWrap2.prototype["@@transducer/result"] = function(acc) {
    return acc;
  };
  XWrap2.prototype["@@transducer/step"] = function(acc, x) {
    return this.f(acc, x);
  };
  return XWrap2;
}();
function _xwrap(fn) {
  return new XWrap(fn);
}
var bind$1 = /* @__PURE__ */ _curry2(function bind(fn, thisObj) {
  return _arity(fn.length, function() {
    return fn.apply(thisObj, arguments);
  });
});
var bind$2 = bind$1;
function _arrayReduce(xf, acc, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    acc = xf["@@transducer/step"](acc, list[idx]);
    if (acc && acc["@@transducer/reduced"]) {
      acc = acc["@@transducer/value"];
      break;
    }
    idx += 1;
  }
  return xf["@@transducer/result"](acc);
}
function _iterableReduce(xf, acc, iter) {
  var step = iter.next();
  while (!step.done) {
    acc = xf["@@transducer/step"](acc, step.value);
    if (acc && acc["@@transducer/reduced"]) {
      acc = acc["@@transducer/value"];
      break;
    }
    step = iter.next();
  }
  return xf["@@transducer/result"](acc);
}
function _methodReduce(xf, acc, obj, methodName) {
  return xf["@@transducer/result"](obj[methodName](bind$2(xf["@@transducer/step"], xf), acc));
}
var symIterator = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
function _reduce(fn, acc, list) {
  if (typeof fn === "function") {
    fn = _xwrap(fn);
  }
  if (_isArrayLike$1(list)) {
    return _arrayReduce(fn, acc, list);
  }
  if (typeof list["fantasy-land/reduce"] === "function") {
    return _methodReduce(fn, acc, list, "fantasy-land/reduce");
  }
  if (list[symIterator] != null) {
    return _iterableReduce(fn, acc, list[symIterator]());
  }
  if (typeof list.next === "function") {
    return _iterableReduce(fn, acc, list);
  }
  if (typeof list.reduce === "function") {
    return _methodReduce(fn, acc, list, "reduce");
  }
  throw new TypeError("reduce: list must be array or iterable");
}
function _has(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var toString = Object.prototype.toString;
var _isArguments = /* @__PURE__ */ function() {
  return toString.call(arguments) === "[object Arguments]" ? function _isArguments2(x) {
    return toString.call(x) === "[object Arguments]";
  } : function _isArguments2(x) {
    return _has("callee", x);
  };
}();
var _isArguments$1 = _isArguments;
var hasEnumBug = !/* @__PURE__ */ {
  toString: null
}.propertyIsEnumerable("toString");
var nonEnumerableProps = ["constructor", "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
var hasArgsEnumBug = /* @__PURE__ */ function() {
  return arguments.propertyIsEnumerable("length");
}();
var contains = function contains2(list, item) {
  var idx = 0;
  while (idx < list.length) {
    if (list[idx] === item) {
      return true;
    }
    idx += 1;
  }
  return false;
};
var keys = typeof Object.keys === "function" && !hasArgsEnumBug ? /* @__PURE__ */ _curry1(function keys2(obj) {
  return Object(obj) !== obj ? [] : Object.keys(obj);
}) : /* @__PURE__ */ _curry1(function keys3(obj) {
  if (Object(obj) !== obj) {
    return [];
  }
  var prop, nIdx;
  var ks = [];
  var checkArgsLength = hasArgsEnumBug && _isArguments$1(obj);
  for (prop in obj) {
    if (_has(prop, obj) && (!checkArgsLength || prop !== "length")) {
      ks[ks.length] = prop;
    }
  }
  if (hasEnumBug) {
    nIdx = nonEnumerableProps.length - 1;
    while (nIdx >= 0) {
      prop = nonEnumerableProps[nIdx];
      if (_has(prop, obj) && !contains(ks, prop)) {
        ks[ks.length] = prop;
      }
      nIdx -= 1;
    }
  }
  return ks;
});
var keys$1 = keys;
var nth = /* @__PURE__ */ _curry2(function nth2(offset, list) {
  var idx = offset < 0 ? list.length + offset : offset;
  return _isString(list) ? list.charAt(idx) : list[idx];
});
var nth$1 = nth;
var isNil = /* @__PURE__ */ _curry1(function isNil2(x) {
  return x == null;
});
var isNil$1 = isNil;
var type = /* @__PURE__ */ _curry1(function type2(val) {
  return val === null ? "Null" : val === void 0 ? "Undefined" : Object.prototype.toString.call(val).slice(8, -1);
});
var type$1 = type;
function _checkForMethod(methodname, fn) {
  return function() {
    var length = arguments.length;
    if (length === 0) {
      return fn();
    }
    var obj = arguments[length - 1];
    return _isArray(obj) || typeof obj[methodname] !== "function" ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
  };
}
var slice = /* @__PURE__ */ _curry3(/* @__PURE__ */ _checkForMethod("slice", function slice2(fromIndex, toIndex, list) {
  return Array.prototype.slice.call(list, fromIndex, toIndex);
}));
var slice$1 = slice;
var tail = /* @__PURE__ */ _curry1(/* @__PURE__ */ _checkForMethod("tail", /* @__PURE__ */ slice$1(1, Infinity)));
var tail$1 = tail;
var head = /* @__PURE__ */ nth$1(0);
var head$1 = head;
function _identity(x) {
  return x;
}
var identity$1 = /* @__PURE__ */ _curry1(_identity);
var identity$2 = identity$1;
var pipeWith = /* @__PURE__ */ _curry2(function pipeWith2(xf, list) {
  if (list.length <= 0) {
    return identity$2;
  }
  var headList = head$1(list);
  var tailList = tail$1(list);
  return _arity(headList.length, function() {
    return _reduce(function(result, f) {
      return xf.call(this, f, result);
    }, headList.apply(this, arguments), tailList);
  });
});
var pipeWith$1 = pipeWith;
function _arrayFromIterator(iter) {
  var list = [];
  var next;
  while (!(next = iter.next()).done) {
    list.push(next.value);
  }
  return list;
}
function _includesWith(pred, x, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    if (pred(x, list[idx])) {
      return true;
    }
    idx += 1;
  }
  return false;
}
function _functionName(f) {
  var match = String(f).match(/^function (\w*)/);
  return match == null ? "" : match[1];
}
function _objectIs(a, b) {
  if (a === b) {
    return a !== 0 || 1 / a === 1 / b;
  } else {
    return a !== a && b !== b;
  }
}
var _objectIs$1 = typeof Object.is === "function" ? Object.is : _objectIs;
function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
  var a = _arrayFromIterator(aIterator);
  var b = _arrayFromIterator(bIterator);
  function eq(_a, _b) {
    return _equals(_a, _b, stackA.slice(), stackB.slice());
  }
  return !_includesWith(function(b2, aItem) {
    return !_includesWith(eq, aItem, b2);
  }, b, a);
}
function _equals(a, b, stackA, stackB) {
  if (_objectIs$1(a, b)) {
    return true;
  }
  var typeA = type$1(a);
  if (typeA !== type$1(b)) {
    return false;
  }
  if (a == null || b == null) {
    return false;
  }
  if (typeof a["fantasy-land/equals"] === "function" || typeof b["fantasy-land/equals"] === "function") {
    return typeof a["fantasy-land/equals"] === "function" && a["fantasy-land/equals"](b) && typeof b["fantasy-land/equals"] === "function" && b["fantasy-land/equals"](a);
  }
  if (typeof a.equals === "function" || typeof b.equals === "function") {
    return typeof a.equals === "function" && a.equals(b) && typeof b.equals === "function" && b.equals(a);
  }
  switch (typeA) {
    case "Arguments":
    case "Array":
    case "Object":
      if (typeof a.constructor === "function" && _functionName(a.constructor) === "Promise") {
        return a === b;
      }
      break;
    case "Boolean":
    case "Number":
    case "String":
      if (!(typeof a === typeof b && _objectIs$1(a.valueOf(), b.valueOf()))) {
        return false;
      }
      break;
    case "Date":
      if (!_objectIs$1(a.valueOf(), b.valueOf())) {
        return false;
      }
      break;
    case "Error":
      return a.name === b.name && a.message === b.message;
    case "RegExp":
      if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
        return false;
      }
      break;
  }
  var idx = stackA.length - 1;
  while (idx >= 0) {
    if (stackA[idx] === a) {
      return stackB[idx] === b;
    }
    idx -= 1;
  }
  switch (typeA) {
    case "Map":
      if (a.size !== b.size) {
        return false;
      }
      return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
    case "Set":
      if (a.size !== b.size) {
        return false;
      }
      return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
    case "Arguments":
    case "Array":
    case "Object":
    case "Boolean":
    case "Number":
    case "String":
    case "Date":
    case "Error":
    case "RegExp":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "ArrayBuffer":
      break;
    default:
      return false;
  }
  var keysA = keys$1(a);
  if (keysA.length !== keys$1(b).length) {
    return false;
  }
  var extendedStackA = stackA.concat([a]);
  var extendedStackB = stackB.concat([b]);
  idx = keysA.length - 1;
  while (idx >= 0) {
    var key = keysA[idx];
    if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
      return false;
    }
    idx -= 1;
  }
  return true;
}
var equals = /* @__PURE__ */ _curry2(function equals2(a, b) {
  return _equals(a, b, [], []);
});
var equals$1 = equals;
function _isObject(x) {
  return Object.prototype.toString.call(x) === "[object Object]";
}
var mergeWithKey = /* @__PURE__ */ _curry3(function mergeWithKey2(fn, l, r) {
  var result = {};
  var k;
  for (k in l) {
    if (_has(k, l)) {
      result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
    }
  }
  for (k in r) {
    if (_has(k, r) && !_has(k, result)) {
      result[k] = r[k];
    }
  }
  return result;
});
var mergeWithKey$1 = mergeWithKey;
var mergeDeepWithKey = /* @__PURE__ */ _curry3(function mergeDeepWithKey2(fn, lObj, rObj) {
  return mergeWithKey$1(function(k, lVal, rVal) {
    if (_isObject(lVal) && _isObject(rVal)) {
      return mergeDeepWithKey2(fn, lVal, rVal);
    } else {
      return fn(k, lVal, rVal);
    }
  }, lObj, rObj);
});
var mergeDeepWithKey$1 = mergeDeepWithKey;
var mergeDeepRight = /* @__PURE__ */ _curry2(function mergeDeepRight2(lObj, rObj) {
  return mergeDeepWithKey$1(function(k, lVal, rVal) {
    return rVal;
  }, lObj, rObj);
});
var mergeDeepRight$1 = mergeDeepRight;
var mergeWith = /* @__PURE__ */ _curry3(function mergeWith2(fn, l, r) {
  return mergeWithKey$1(function(_, _l, _r) {
    return fn(_l, _r);
  }, l, r);
});
var mergeWith$1 = mergeWith;
var pick = /* @__PURE__ */ _curry2(function pick2(names, obj) {
  var result = {};
  var idx = 0;
  while (idx < names.length) {
    if (names[idx] in obj) {
      result[names[idx]] = obj[names[idx]];
    }
    idx += 1;
  }
  return result;
});
var pick$1 = pick;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var Args$1 = { exports: {} };
(function(module2) {
  (function(name2, context2, definition) {
    if (module2.exports) {
      module2.exports = definition();
    } else {
      context2[name2] = definition();
    }
  })("Args", commonjsGlobal, function argsDefinition() {
    if (!Array.isArray) {
      Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === "[object Array]";
      };
    }
    var _extractSchemeEl = function(rawSchemeEl) {
      var schemeEl = {};
      schemeEl.defValue = void 0;
      schemeEl.typeValue = void 0;
      schemeEl.customCheck = void 0;
      for (var name2 in rawSchemeEl) {
        if (!rawSchemeEl.hasOwnProperty(name2))
          continue;
        if (name2 === "_default") {
          schemeEl.defValue = rawSchemeEl[name2];
        } else if (name2 === "_type") {
          schemeEl.typeValue = rawSchemeEl[name2];
        } else if (name2 === "_check") {
          schemeEl.customCheck = rawSchemeEl[name2];
        } else {
          schemeEl.sname = name2;
        }
      }
      schemeEl.sarg = rawSchemeEl[schemeEl.sname];
      if (typeof schemeEl.customCheck === "object" && schemeEl.customCheck instanceof RegExp) {
        var schemeRegexp = schemeEl.customCheck;
        schemeEl.customCheck = function(arg) {
          return !!arg.toString().match(schemeRegexp);
        };
      }
      return schemeEl;
    };
    var _typeMatches = function(arg, schemeEl) {
      var ok = false;
      if ((schemeEl.sarg & Args2.ANY) !== 0) {
        ok = true;
      } else if ((schemeEl.sarg & Args2.STRING) !== 0 && typeof arg === "string") {
        ok = true;
      } else if ((schemeEl.sarg & Args2.FUNCTION) !== 0 && typeof arg === "function") {
        ok = true;
      } else if ((schemeEl.sarg & Args2.INT) !== 0 && (typeof arg === "number" && Math.floor(arg) === arg)) {
        ok = true;
      } else if ((schemeEl.sarg & Args2.FLOAT) !== 0 && typeof arg === "number") {
        ok = true;
      } else if ((schemeEl.sarg & Args2.ARRAY) !== 0 && Array.isArray(arg)) {
        ok = true;
      } else if (((schemeEl.sarg & Args2.OBJECT) !== 0 || schemeEl.typeValue !== void 0) && (typeof arg === "object" && (schemeEl.typeValue === void 0 || arg instanceof schemeEl.typeValue))) {
        ok = true;
      } else if ((schemeEl.sarg & Args2.ARRAY_BUFFER) !== 0 && arg.toString().match(/ArrayBuffer/)) {
        ok = true;
      } else if ((schemeEl.sarg & Args2.DATE) !== 0 && arg instanceof Date) {
        ok = true;
      } else if ((schemeEl.sarg & Args2.BOOL) !== 0 && typeof arg === "boolean") {
        ok = true;
      } else if ((schemeEl.sarg & Args2.DOM_EL) !== 0 && (arg instanceof HTMLElement || window.$ !== void 0 && arg instanceof window.$)) {
        ok = true;
      }
      if (schemeEl.customCheck !== void 0 && typeof schemeEl.customCheck === "function") {
        if (schemeEl.customCheck(arg)) {
          ok = true;
        } else {
          ok = false;
        }
      }
      return ok;
    };
    var _isTypeSpecified = function(schemeEl) {
      return (schemeEl.sarg & (Args2.ANY | Args2.STRING | Args2.FUNCTION | Args2.INT | Args2.FLOAT | Args2.OBJECT | Args2.ARRAY_BUFFER | Args2.DATE | Args2.BOOL | Args2.DOM_EL | Args2.ARRAY)) != 0 || schemeEl.typeValue !== void 0;
    };
    var _getTypeString = function(schemeEl) {
      var sarg = schemeEl.sarg;
      var typeValue = schemeEl.typeValue;
      var customCheck = schemeEl.customCheck;
      if ((sarg & Args2.STRING) !== 0) {
        return "String";
      }
      if ((sarg & Args2.FUNCTION) !== 0) {
        return "Function";
      }
      if ((sarg & Args2.INT) !== 0) {
        return "Int";
      }
      if ((sarg & Args2.FLOAT) !== 0) {
        return "Float";
      }
      if ((sarg & Args2.ARRAY) !== 0) {
        return "Array";
      }
      if ((sarg & Args2.OBJECT) !== 0) {
        if (typeValue !== void 0) {
          return "Object (" + typeValue.toString() + ")";
        } else {
          return "Object";
        }
      }
      if ((sarg & Args2.ARRAY_BUFFER) !== 0) {
        return "Arry Buffer";
      }
      if ((sarg & Args2.DATE) !== 0) {
        return "Date";
      }
      if ((sarg & Args2.BOOL) !== 0) {
        return "Bool";
      }
      if ((sarg & Args2.DOM_EL) !== 0) {
        return "DOM Element";
      }
      if (customCheck !== void 0) {
        return "[Custom checker]";
      }
      return "unknown";
    };
    var _checkNamedArgs = function(namedArgs, scheme, returns) {
      var foundOne = false;
      for (var s = 0; s < scheme.length; s++) {
        var found = function(schemeEl) {
          var argFound = false;
          for (var name2 in namedArgs) {
            var namedArg = namedArgs[name2];
            if (name2 === schemeEl.sname) {
              if (_typeMatches(namedArg, schemeEl)) {
                returns[name2] = namedArg;
                argFound = true;
                break;
              }
            }
          }
          return argFound;
        }(_extractSchemeEl(scheme[s]));
        if (found) {
          scheme.splice(s--, 1);
        }
        foundOne |= found;
      }
      return foundOne;
    };
    var _schemesMatch = function(schemeA, schemeB) {
      if (!schemeA || !schemeB) {
        return false;
      }
      return (schemeA.sarg & ~(Args2.Optional | Args2.Required)) === (schemeB.sarg & ~(Args2.Optional | Args2.Required)) && schemeA.typeValue === schemeB.typeValue;
    };
    var _isRequired = function(sarg) {
      return !_isOptional(sarg);
    };
    var _isOptional = function(sarg) {
      return (sarg & Args2.Optional) !== 0;
    };
    var _reasonForFailure = function(schemeEl, a, arg) {
      var err = "";
      if (_isTypeSpecified(schemeEl)) {
        err = "Argument " + a + " (" + schemeEl.sname + ") should be type " + _getTypeString(schemeEl) + ", but it was type " + typeof arg + " with value " + arg + ".";
      } else if (schemeEl.customCheck !== void 0) {
        var funcString = schemeEl.customCheck.toString();
        if (funcString.length > 50) {
          funcString = funcString.substr(0, 40) + "..." + funcString.substr(funcString.length - 10);
        }
        err = "Argument " + a + " (" + schemeEl.sname + ") does not pass the custom check (" + funcString + ").";
      } else {
        err = "Argument " + a + " (" + schemeEl.sname + ") has no valid type specified.";
      }
      return err;
    };
    var Args2 = function(scheme, args) {
      if (scheme === void 0)
        throw new Error("The scheme has not been passed.");
      if (args === void 0)
        throw new Error("The arguments have not been passed.");
      args = Array.prototype.slice.call(args, 0);
      var returns = {};
      var err = void 0;
      var runType = void 0;
      var run = [];
      var _addToRun = function(schemeEl) {
        if (!runType || !_schemesMatch(runType, schemeEl) || _isRequired(runType.sarg) && _isOptional(schemeEl.sarg)) {
          run = [];
        }
        if (run.length > 0 || _isOptional(schemeEl.sarg)) {
          runType = schemeEl;
          run.push(schemeEl);
        }
      };
      var _shiftRun = function(schemeEl, a2, r) {
        if (r === void 0)
          r = run.length - 1;
        if (r < 0)
          return;
        var lastMatch = run[r];
        var arg = returns[lastMatch.sname];
        if (_typeMatches(arg, schemeEl)) {
          returns[schemeEl.sname] = arg;
          returns[lastMatch.sname] = lastMatch.defValue || void 0;
          if ((lastMatch.sarg & Args2.Optional) === 0) {
            _shiftRun(lastMatch, a2, r - 1);
          }
        } else {
          return _reasonForFailure(schemeEl, a2, arg);
        }
      };
      var a, s;
      var lastArg = args[args.length - 1];
      if (lastArg !== null && typeof lastArg === "object" && lastArg.constructor === Object) {
        if (_checkNamedArgs(args[args.length - 1], scheme, returns)) {
          args.splice(args.length - 1, 1);
        }
      }
      for (a = 0, s = 0; s < scheme.length; s++) {
        a = function(a2, s2) {
          var arg = args[a2];
          if (scheme[s2] instanceof Array) {
            var group = scheme[s2];
            var retName = void 0;
            var groupIsOptional = false;
            for (var g = 0; g < group.length; g++) {
              var groupEl = group[g];
              if (groupEl === Args2.Optional) {
                groupIsOptional = true;
              } else {
                var schemeEl = _extractSchemeEl(groupEl);
                if (_typeMatches(arg, schemeEl)) {
                  retName = schemeEl.sname;
                }
              }
            }
            if (retName === void 0 && !groupIsOptional) {
              if (arg === null || arg === void 0) {
                err = "Argument " + a2 + " is null or undefined but it must be not null.";
                return a2;
              }
              err = "Argument " + a2 + " should be one of: ";
              for (var g = 0; g < group.length; g++) {
                var schemeEl = _extractSchemeEl(group[g]);
                err += _getTypeString(schemeEl) + ", ";
              }
              err += "but it was type " + typeof arg + " with value " + arg + ".";
              return a2;
            } else if (retName !== void 0) {
              returns[retName] = arg;
              return a2 + 1;
            }
          } else {
            var schemeEl = _extractSchemeEl(scheme[s2]);
            if ((schemeEl.sarg & Args2.Optional) !== 0) {
              if (arg === null || arg === void 0) {
                if (schemeEl.defValue !== void 0) {
                  returns[schemeEl.sname] = schemeEl.defValue;
                } else {
                  returns[schemeEl.sname] = arg;
                }
                return a2 + 1;
              } else if (_typeMatches(arg, schemeEl)) {
                returns[schemeEl.sname] = arg;
                _addToRun(schemeEl);
                return a2 + 1;
              } else if (schemeEl.defValue !== void 0) {
                returns[schemeEl.sname] = schemeEl.defValue;
                return a2;
              }
            } else {
              if (arg === null || arg === void 0) {
                if (_isTypeSpecified(schemeEl) && _schemesMatch(schemeEl, runType)) {
                  err = _shiftRun(schemeEl, a2);
                  if (err === "") {
                    _addToRun(schemeEl);
                  }
                  return a2;
                } else {
                  err = "Argument " + a2 + " (" + schemeEl.sname + ") is null or undefined but it must be not null.";
                  return a2;
                }
              } else if (!_typeMatches(arg, schemeEl)) {
                if (_isTypeSpecified(schemeEl) && _schemesMatch(schemeEl, runType)) {
                  err = _shiftRun(schemeEl, a2);
                  if (err === "") {
                    _addToRun(schemeEl);
                    return a2 + 1;
                  }
                } else {
                  err = _reasonForFailure(schemeEl, a2, arg);
                }
                return a2;
              } else {
                returns[schemeEl.sname] = arg;
                _addToRun(schemeEl);
                return a2 + 1;
              }
            }
          }
          return a2;
        }(a, s);
        if (err) {
          break;
        }
      }
      if (err) {
        throw new Error(err);
      }
      return returns;
    };
    Args2.ANY = 1;
    Args2.STRING = 1 << 1;
    Args2.FUNCTION = 1 << 2;
    Args2.INT = 1 << 3;
    Args2.FLOAT = 1 << 4;
    Args2.ARRAY_BUFFER = 1 << 5;
    Args2.OBJECT = 1 << 6;
    Args2.DATE = 1 << 7;
    Args2.BOOL = 1 << 8;
    Args2.DOM_EL = 1 << 9;
    Args2.ARRAY = 1 << 10;
    Args2.Optional = 1 << 11;
    Args2.NotNull = Args2.Required = 1 << 12;
    return Args2;
  });
})(Args$1);
var Args = Args$1.exports;
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function isFunction(value) {
  return typeof value === "function";
}
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty = new Subscription2();
    empty.closed = true;
    return empty;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    {
      throw err;
    }
  });
}
function noop() {
}
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind2(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind2(observerOrNext.next, context_1),
          error: observerOrNext.error && bind2(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind2(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x) {
  return x;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});
var isArrayLike2 = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}
function isInteropObservable(input) {
  return isFunction(input[observable]);
}
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike2(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
  if (delay === void 0) {
    delay = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
function observeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay);
    }));
  });
}
function subscribeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay));
  });
}
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator$1;
    executeSchedule(subscriber, scheduler, function() {
      iterator$1 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator$1.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return();
    };
  });
}
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike2(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}
function take(count) {
  return count <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count) {
        subscriber.next(value);
        if (count <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.connector, connector = _a === void 0 ? function() {
    return new Subject();
  } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection = null;
    var resetConnection = null;
    var subject = null;
    var refCount = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = null;
    };
    var reset = function() {
      cancelReset();
      connection = subject = null;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount--;
        if (refCount === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        from(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return null;
  }
  if (on === false) {
    return null;
  }
  return on.apply(void 0, __spreadArray([], __read(args))).pipe(take(1)).subscribe(function() {
    return reset();
  });
}
const MAGIC_STRING = "voerka-json-bigint-2022";
function replacer(key, value) {
  if (typeof value === "bigint") {
    return `${MAGIC_STRING}${value.toString()}${MAGIC_STRING}`;
  }
  return value;
}
function reviver(key, value) {
  if (value != null) {
    if (typeof value === "string" && /^\d+$/.test(value) && Number(value) > Number.MAX_SAFE_INTEGER) {
      return BigInt(value);
    }
    if (typeof value === "number" && value > Number.MAX_SAFE_INTEGER) {
      return BigInt(value);
    }
  }
  return value;
}
function getReviver(type3) {
  return (key, value) => {
    if (value != null) {
      if (typeof value === "string" && /^\d+$/.test(value) && Number(value) > Number.MAX_SAFE_INTEGER) {
        return type3(BigInt(value));
      }
      if (typeof value === "number" && value > Number.MAX_SAFE_INTEGER) {
        return type3(BigInt(value));
      }
    }
    return value;
  };
}
class JSONBigInt {
  static parse(str, type3) {
    return JSON.parse(str, type3 ? getReviver(type3) : reviver);
  }
  static stringify(obj) {
    let res = JSON.stringify(obj, replacer);
    {
      res = res.replaceAll(`"${MAGIC_STRING}`, "").replaceAll(`${MAGIC_STRING}"`, "");
    }
    return res;
  }
}
const _g$1 = globalThis || window || global;
function getLogger() {
  const adapter = Object.assign({}, _g$1.console);
  adapter.debug = console.log;
  adapter.fatal = console.error;
  return adapter;
}
function prefix(prefixs = []) {
  return function(logger) {
    const typeList = ["debug", "info", "warn", "error", "fatal"];
    const writer = {};
    typeList.forEach((type3) => {
      const out = logger[type3];
      writer[type3] = (...args) => {
        return out.call(logger, ...prefixs, ...args);
      };
    });
    return writer;
  };
}
function useLogger(name2 = "vlogger", { prefixs = [], global: global2 = false } = {}) {
  const _logger2 = _g$1.logger || getLogger();
  if (!prefixs.length) {
    prefixs = [`[${name2}]`];
  } else {
    prefixs = prefixs.map((item) => `[${item}]`);
  }
  prefix(prefixs)(_logger2);
  if (global2) {
    _g$1[name2] = _logger2;
  }
  return _logger2;
}
const name$1 = "@voerka/messager";
const version$1 = "2.4.10";
const description = "mqtt\u5BA2\u6237\u7AEF";
const files = [
  "dist",
  "src"
];
const main = "dist/messager.umd.js";
const module = "dist/messager.es.js";
const types = "dist/index.d.ts";
const scripts = {
  build: "vite build"
};
const author = {
  name: "sclin"
};
const dependencies = {
  "args-js": "^0.10.12",
  flakeid: "^1.0.0",
  md5: "^2.3.0",
  mqtt: "^4.2.6",
  msgpack5: "^5.0.0"
};
const devDependencies = {
  "@voerka/json-bigint": "2.4.8",
  "@voerka/logger": "2.4.10",
  ramda: "^0.27.0",
  rxjs: "^7.0.1",
  vite: "^2.1.2"
};
const license = "ISC";
var pkg = {
  name: name$1,
  version: version$1,
  description,
  files,
  main,
  module,
  types,
  scripts,
  author,
  dependencies,
  devDependencies,
  license
};
const { name, version } = pkg;
var _logger = useLogger("mlogger", { prefixs: [`${name}@${version}`] });
const msgpack = msgpack5();
function Uint8ArrayToString(fileData) {
  var dataString = "";
  for (var i = 0; i < fileData.length; i++) {
    dataString += String.fromCharCode(fileData[i]);
  }
  return dataString;
}
function isDataJson(data) {
  const res = Uint8ArrayToString(data);
  try {
    JSON.parse(res);
  } catch (error) {
    return false;
  }
  return res || true;
}
function serialize(message, { pack = false } = {}) {
  let tempMsg = message;
  try {
    tempMsg = JSONBigInt.stringify(message);
  } catch (error) {
    _logger.error("JSONBig stringify", error.message);
  }
  if (pack) {
    try {
      tempMsg = msgpack.encode(tempMsg);
    } catch (error) {
      _logger.error("msgpack encode", error.message);
    }
  }
  return tempMsg;
}
function deserialize(data) {
  if (!isDataJson(data)) {
    try {
      data = msgpack.decode(data);
    } catch (error) {
      _logger.error("msgpack decode", error.message);
    }
  }
  try {
    data = JSONBigInt.parse(data, String);
  } catch (error) {
    _logger.error("JSONBig parse", error.message);
  }
  return data;
}
var md5$1 = { exports: {} };
var crypt = { exports: {} };
(function() {
  var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt$1 = {
    rotl: function(n, b) {
      return n << b | n >>> 32 - b;
    },
    rotr: function(n, b) {
      return n << 32 - b | n >>> b;
    },
    endian: function(n) {
      if (n.constructor == Number) {
        return crypt$1.rotl(n, 8) & 16711935 | crypt$1.rotl(n, 24) & 4278255360;
      }
      for (var i = 0; i < n.length; i++)
        n[i] = crypt$1.endian(n[i]);
      return n;
    },
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << 24 - b % 32;
      return words;
    },
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push(words[b >>> 5] >>> 24 - b % 32 & 255);
      return bytes;
    },
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 15).toString(16));
      }
      return hex.join("");
    },
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63));
          else
            base64.push("=");
      }
      return base64.join("");
    },
    base64ToBytes: function(base64) {
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
      for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
        if (imod4 == 0)
          continue;
        bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
      }
      return bytes;
    }
  };
  crypt.exports = crypt$1;
})();
var charenc = {
  utf8: {
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },
  bin: {
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 255);
      return bytes;
    },
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join("");
    }
  }
};
var charenc_1 = charenc;
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var isBuffer_1 = function(obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};
function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
}
(function() {
  var crypt$1 = crypt.exports, utf8 = charenc_1.utf8, isBuffer2 = isBuffer_1, bin = charenc_1.bin, md52 = function(message, options) {
    if (message.constructor == String)
      if (options && options.encoding === "binary")
        message = bin.stringToBytes(message);
      else
        message = utf8.stringToBytes(message);
    else if (isBuffer2(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message) && message.constructor !== Uint8Array)
      message = message.toString();
    var m = crypt$1.bytesToWords(message), l = message.length * 8, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
    for (var i = 0; i < m.length; i++) {
      m[i] = (m[i] << 8 | m[i] >>> 24) & 16711935 | (m[i] << 24 | m[i] >>> 8) & 4278255360;
    }
    m[l >>> 5] |= 128 << l % 32;
    m[(l + 64 >>> 9 << 4) + 14] = l;
    var FF = md52._ff, GG = md52._gg, HH = md52._hh, II = md52._ii;
    for (var i = 0; i < m.length; i += 16) {
      var aa = a, bb = b, cc = c, dd = d;
      a = FF(a, b, c, d, m[i + 0], 7, -680876936);
      d = FF(d, a, b, c, m[i + 1], 12, -389564586);
      c = FF(c, d, a, b, m[i + 2], 17, 606105819);
      b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i + 4], 7, -176418897);
      d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
      c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i + 7], 22, -45705983);
      a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
      d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i + 10], 17, -42063);
      b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
      a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
      d = FF(d, a, b, c, m[i + 13], 12, -40341101);
      c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
      b = FF(b, c, d, a, m[i + 15], 22, 1236535329);
      a = GG(a, b, c, d, m[i + 1], 5, -165796510);
      d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
      c = GG(c, d, a, b, m[i + 11], 14, 643717713);
      b = GG(b, c, d, a, m[i + 0], 20, -373897302);
      a = GG(a, b, c, d, m[i + 5], 5, -701558691);
      d = GG(d, a, b, c, m[i + 10], 9, 38016083);
      c = GG(c, d, a, b, m[i + 15], 14, -660478335);
      b = GG(b, c, d, a, m[i + 4], 20, -405537848);
      a = GG(a, b, c, d, m[i + 9], 5, 568446438);
      d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
      c = GG(c, d, a, b, m[i + 3], 14, -187363961);
      b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
      a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
      d = GG(d, a, b, c, m[i + 2], 9, -51403784);
      c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
      b = GG(b, c, d, a, m[i + 12], 20, -1926607734);
      a = HH(a, b, c, d, m[i + 5], 4, -378558);
      d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
      b = HH(b, c, d, a, m[i + 14], 23, -35309556);
      a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
      d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
      c = HH(c, d, a, b, m[i + 7], 16, -155497632);
      b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
      a = HH(a, b, c, d, m[i + 13], 4, 681279174);
      d = HH(d, a, b, c, m[i + 0], 11, -358537222);
      c = HH(c, d, a, b, m[i + 3], 16, -722521979);
      b = HH(b, c, d, a, m[i + 6], 23, 76029189);
      a = HH(a, b, c, d, m[i + 9], 4, -640364487);
      d = HH(d, a, b, c, m[i + 12], 11, -421815835);
      c = HH(c, d, a, b, m[i + 15], 16, 530742520);
      b = HH(b, c, d, a, m[i + 2], 23, -995338651);
      a = II(a, b, c, d, m[i + 0], 6, -198630844);
      d = II(d, a, b, c, m[i + 7], 10, 1126891415);
      c = II(c, d, a, b, m[i + 14], 15, -1416354905);
      b = II(b, c, d, a, m[i + 5], 21, -57434055);
      a = II(a, b, c, d, m[i + 12], 6, 1700485571);
      d = II(d, a, b, c, m[i + 3], 10, -1894986606);
      c = II(c, d, a, b, m[i + 10], 15, -1051523);
      b = II(b, c, d, a, m[i + 1], 21, -2054922799);
      a = II(a, b, c, d, m[i + 8], 6, 1873313359);
      d = II(d, a, b, c, m[i + 15], 10, -30611744);
      c = II(c, d, a, b, m[i + 6], 15, -1560198380);
      b = II(b, c, d, a, m[i + 13], 21, 1309151649);
      a = II(a, b, c, d, m[i + 4], 6, -145523070);
      d = II(d, a, b, c, m[i + 11], 10, -1120210379);
      c = II(c, d, a, b, m[i + 2], 15, 718787259);
      b = II(b, c, d, a, m[i + 9], 21, -343485551);
      a = a + aa >>> 0;
      b = b + bb >>> 0;
      c = c + cc >>> 0;
      d = d + dd >>> 0;
    }
    return crypt$1.endian([a, b, c, d]);
  };
  md52._ff = function(a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return (n << s | n >>> 32 - s) + b;
  };
  md52._gg = function(a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return (n << s | n >>> 32 - s) + b;
  };
  md52._hh = function(a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return (n << s | n >>> 32 - s) + b;
  };
  md52._ii = function(a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return (n << s | n >>> 32 - s) + b;
  };
  md52._blocksize = 16;
  md52._digestsize = 16;
  md5$1.exports = function(message, options) {
    if (message === void 0 || message === null)
      throw new Error("Illegal argument " + message);
    var digestbytes = crypt$1.wordsToBytes(md52(message, options));
    return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt$1.bytesToHex(digestbytes);
  };
})();
var md5 = md5$1.exports;
String.prototype.toVoerkaTopic = function(params) {
  const ParamRegExp = /\{\w*\}/g;
  let result = this;
  params = Object.assign({ tid: 0 }, params);
  if (params.tid) {
    if (result.indexOf("%{tid}%") > -1)
      ;
    else {
      result = result.replace("{domain}", `{domain}/%{tid}%`);
    }
  }
  if (Array.isArray(params)) {
    let i = 0;
    for (let match of result.match(ParamRegExp) || []) {
      if (i < params.length) {
        result = result.replace(match, params[i]);
        i += 1;
      }
    }
  } else if (typeof params === "object") {
    for (let name2 in params) {
      result = result.replace("{" + name2 + "}", params[name2]);
    }
  }
  return result;
};
const TOPICS = {
  DEVICE: "/voerka/{domain}/devices/{sn}/#",
  REGISTER: "/voerka/{domain}/register",
  NOTIFY: "/voerka/{domain}/devices/{sn}/notify",
  ATTRS: "/voerka/{domain}/devices/{sn}/attrs",
  STATUS: "/voerka/{domain}/devices/{sn}/status",
  ACTIONS: "/voerka/{domain}/devices/{sn}/actions",
  ALARMS: "/voerka/{domain}/devices/{sn}/alarms",
  EVENTS: "/voerka/{domain}/devices/{sn}/events",
  EVENTS_STATUS: "/voerka/{domain}/devices/{sn}/status",
  MESSAGE: "/voerka/{domain}/devices/{sn}/message",
  DATA: "/voerka/{domain}/devices/{sn}/data",
  QUERY: "/voerka/{domain}/devices/{sn}/query",
  BROADCAST: "/voerka/{domain}/broadcast/{group}",
  ANSWER: "/voerka/{domain}/devices/{sn}/answer",
  DEVICE_GROUP: "/voerka/{domain}/+/groups/{group}/#",
  NOTIFY_GROUP: "/voerka/{domain}/%{tid}%/groups/{group}/$$notify",
  ATTRS_GROUP: "/voerka/{domain}/%{tid}%/groups/{group}/$$attrs",
  STATUS_GROUP: "/voerka/{domain}/%{tid}%/groups/{group}/$$status",
  ACTIONS_GROUP: "/voerka/{domain}/%{tid}%/groups/{group}/$$actions",
  ALARMS_GROUP: "/voerka/{domain}/%{tid}%/groups/{group}/$$alarms",
  EVENTS_GROUP: "/voerka/{domain}/%{tid}%/groups/{group}/$$events",
  EVENTS_STATUS_GROUP: "/voerka/{domain}/%{tid}%/groups/{group}/$status",
  MESSAGE_GROUP: "/voerka/{domain}/%{tid}%/groups/{group}/$$message",
  DATA_GROUP: "/voerka/{domain}/%{tid}%/groups/{group}/$$data",
  QUERY_GROUP: "/voerka/{domain}/%{tid}%/groups/{group}/$$query",
  ANSWER_GROUP: "/voerka/{domain}/%{tid}%/groups/{group}/$$answer",
  RESOURCE: "/voerka/{domain}/rs/{type}/{id}",
  RESOURCE_SUB: "/voerka/{domain}/rs/{type}/{id}/{sub_type}/{sub_id}"
};
const MESSAGE_TYPE = {
  REGISTER: 0,
  NOTIFY: 1,
  ATTRS: 2,
  STATUS: 3,
  ACTIONS: 4,
  ALARMS: 5,
  EVENTS: 6,
  MESSAGE: 7,
  DATA: 8,
  QUERY: 9,
  BROADCAST: 10,
  ANSWER: 11
};
const EVENT_CODE = {
  DEVICE_READY: 1e3,
  DEVICE_STATUS_CHANGED: 1001,
  DEVICE_ATTRS_CHANGED: 1002,
  DEVICE_TRANS_PROGRESS: 1003,
  DEVICE_BEFORE_SHUTDOWN: 1004,
  DEVICE_ALARM_CANCELLED: 1005,
  DEVICE_ALARM_HANDLED: 1006,
  DEVICE_REPORT: 1007,
  RESOURCE_CREATED: 3001,
  RESOURCE_UPDATED: 3002,
  RESOURCE_DELETED: 3003,
  RESOURCE_PUSHED: 3004,
  RESOURCE_POPED: 3005,
  RESOURCE_MOVED: 3006,
  RESOURCE_JUMPED: 3007,
  RESOURCE_SWAPED: 3008,
  IO_KEY: 4e3,
  APPLICATION_CALL: 8e4
};
const ALARM_CODE = {
  DEVICE_CHECK: 1e3,
  DEVICE_SCREEN_ABNORMAL: 1001,
  DEVICE_LOW_BATTERY: 1002,
  DEVICE_MODULE_ABNORMAL: 1003,
  DEVICE_INSUFFICIENT_STORAGE: 1004,
  DEVICE_FIRMWARE_UPGRADE_FAILED: 1005,
  DEVICE_LOG_FULL: 1006,
  DEVICE_UNABLE_CONNECT_LOG_SERVER: 1007,
  DEVICE_REMOTE_DEBUG: 1008,
  DEVICE_INSUFFICIENT_MEMORY: 1009,
  DEVICE_CPU_OVER_LOAD: 1010,
  DEVICE_SUB_DEVICE_REGISTER_FAILED: 1011,
  DEVICE_POWER_DISCONNECTED: 1012,
  DEVICE_ANTI_DISMANTLING: 1013
};
const ALARM_LEVEL = {
  DEVICE_CHECK: 4,
  DEVICE_SCREEN_ABNORMAL: 3,
  DEVICE_LOW_BATTERY: 4,
  DEVICE_MODULE_ABNORMAL: 1,
  DEVICE_INSUFFICIENT_STORAGE: 3,
  DEVICE_FIRMWARE_UPGRADE_FAILED: 3,
  DEVICE_LOG_FULL: 5,
  DEVICE_UNABLE_CONNECT_LOG_SERVER: 3,
  DEVICE_REMOTE_DEBUG: 1,
  DEVICE_INSUFFICIENT_MEMORY: 5,
  DEVICE_CPU_OVER_LOAD: 3,
  DEVICE_SUB_DEVICE_REGISTER_FAILED: 2,
  DEVICE_POWER_DISCONNECTED: 3,
  DEVICE_ANTI_DISMANTLING: 3
};
const RESPONSE_CODE = {
  RECEIVED: 100,
  OK: 200,
  OK_DOING: 201,
  OK_DONE: 200,
  ERROR: 500,
  PERMISSION_DENIED: 501,
  COMMUNICATION: 502,
  UNKNOWN_COMMAND: 503,
  REJECTED: 504,
  INSUFFICIENT: 505
};
const TRANSACTION_RESULT = {
  INITIAL: 0,
  HANDLING: 1,
  SUSPENDED: 2,
  RESUMED: 3,
  COMPLETED: 10,
  NOT_SERVICED: 11,
  IGNORED: 12,
  TRANSFERRED: 13,
  REJECTED: 14,
  TIMEOUT: 15,
  MISTAKE: 16,
  ERROR: 19
};
const TRANSACTION_STATUS = {
  TODO: 0,
  PROGRESSING: 1,
  COMPLETED: 2
};
function defineMessage(message = {}, options = {}) {
  return mergeDeepRight$1({
    type: 0,
    from: "",
    to: "",
    sid: 0,
    timestamp: Date.now(),
    token: "",
    tid: 0,
    flags: {},
    payload: {}
  }, message);
}
function getMessageId(message = {}) {
  if (message.from && message.timestamp) {
    const id = (md5(message.from + message.timestamp) + "").toLowerCase();
    return id;
  } else {
    return Date.now() + "";
  }
}
function add(x, y, base) {
  var z = [];
  var n = Math.max(x.length, y.length);
  var carry = 0;
  var i = 0;
  while (i < n || carry) {
    var xi = i < x.length ? x[i] : 0;
    var yi = i < y.length ? y[i] : 0;
    var zi = carry + xi + yi;
    z.push(zi % base);
    carry = Math.floor(zi / base);
    i++;
  }
  return z;
}
function multiplyByNumber(num, x, base) {
  if (num < 0)
    return null;
  if (num == 0)
    return [];
  var result = [];
  var power = x;
  while (true) {
    if (num & 1) {
      result = add(result, power, base);
    }
    num = num >> 1;
    if (num === 0)
      break;
    power = add(power, power, base);
  }
  return result;
}
function parseToDigitsArray(str, base) {
  var digits = str.split("");
  var ary = [];
  for (var i = digits.length - 1; i >= 0; i--) {
    var n = parseInt(digits[i], base);
    if (isNaN(n))
      return null;
    ary.push(n);
  }
  return ary;
}
function convertBase(str, fromBase, toBase) {
  var digits = parseToDigitsArray(str, fromBase);
  if (digits === null)
    return null;
  var outArray = [];
  var power = [1];
  for (var i = 0; i < digits.length; i++) {
    if (digits[i]) {
      outArray = add(outArray, multiplyByNumber(digits[i], power, toBase), toBase);
    }
    power = multiplyByNumber(fromBase, power, toBase);
  }
  var out = "";
  for (var i = outArray.length - 1; i >= 0; i--) {
    out += outArray[i].toString(toBase);
  }
  return out;
}
function hexToDec(hexStr) {
  if (hexStr.substring(0, 2) === "0x")
    hexStr = hexStr.substring(2);
  hexStr = hexStr.toLowerCase();
  return convertBase(hexStr, 16, 10);
}
class FlakeId {
  constructor(options) {
    options = options || {};
    this.seq = 0;
    this.mid = (options.mid || 1) % 1023;
    this.timeOffset = options.timeOffset || 0;
    this.lastTime = 0;
  }
  gen() {
    const time = Date.now(), bTime = (time - this.timeOffset).toString(2);
    if (this.lastTime == time) {
      this.seq++;
      if (this.seq > 4095) {
        this.seq = 0;
      }
    } else {
      this.seq = 0;
    }
    this.lastTime = time;
    let bSeq = this.seq.toString(2), bMid = this.mid.toString(2);
    while (bSeq.length < 12)
      bSeq = "0" + bSeq;
    while (bMid.length < 10)
      bMid = "0" + bMid;
    const bid = bTime + bMid + bSeq;
    let id = "";
    for (let i = bid.length; i > 0; i -= 4) {
      id = parseInt(bid.substring(i - 4, i), 2).toString(16) + id;
    }
    return hexToDec(id);
  }
}
const mergeWithValue = mergeWith$1((l, r) => r || l);
function trim(str = "", char, type3) {
  if (char) {
    if (type3 == "left") {
      return str.replace(new RegExp("^\\" + char + "+", "g"), "");
    } else if (type3 == "right") {
      return str.replace(new RegExp("\\" + char + "+$", "g"), "");
    }
    return str.replace(new RegExp("^\\" + char + "+|\\" + char + "+$", "g"), "");
  }
  return str.replace(/^\s+|\s+$/g, "");
}
function setup() {
  if (!this.voerka) {
    this._sid = 1;
    const { voerka = {} } = this._options.master;
    this.voerka = this._getOptions(voerka);
  }
  this.answerObservable = this.getTopicObservable(TOPICS.ANSWER.toVoerkaTopic(this.voerka));
  const deviceTopic = TOPICS.DEVICE.toVoerkaTopic(this.voerka);
  this.subscribe(deviceTopic);
  this.voerka.subscriptions.forEach((topic) => {
    topic = topic.toVoerkaTopic(this.voerka);
    if (topic !== deviceTopic) {
      this.subscribe(topic);
    }
  });
  this._tidGenerator = new FlakeId(this.voerka.flake);
  _logger.info("subscriptions", this.subscriptions);
}
var VoerkaPlugin = {
  name: "voerka",
  setup,
  _getOptions(options = {}) {
    return mergeDeepRight$1({
      sn: "voerka_demo1",
      domain: "hispro",
      group: "",
      sessionTimeout: 30 * 1e3,
      bufferMax: 100,
      flake: {},
      subscriptions: []
    }, options);
  },
  update(options) {
    this._assertMaster();
    let { voerka = {} } = options;
    voerka = this._getOptions(voerka);
    const focus = ["sn", "domain", "subscriptions"];
    const resubscribe = focus.some((key) => !equals$1(voerka[key], this.voerka[key]));
    this.voerka = voerka;
    if (resubscribe) {
      _logger.info("subscriptions", this.subscriptions);
      _logger.warn(`key option: [${focus}] updated, Resubscribe!!!`);
      this.subscriptions.forEach((topic) => {
        this.unsubscribe(topic);
      });
      setup.call(this);
    }
  },
  _createMessageInSubject() {
    this._messageBuffer = {};
    this._messageIdList = [];
    const pushInBuffer = (id) => {
      if (this._messageIdList.length >= this.voerka.bufferMax) {
        delete this._messageBuffer[this._messageIdList.shift()];
      }
      this._messageIdList.push(id);
      this._messageBuffer[id] = true;
    };
    return new Subject().pipe(map((item) => {
      item.message.id = getMessageId(item.message);
      return item;
    }), filter((item) => {
      const { id } = item.message;
      if (id in this._messageBuffer) {
        return false;
      } else {
        pushInBuffer(id);
        return true;
      }
    }), share());
  },
  defineMessage(message = {}, options = {}) {
    return defineMessage(mergeDeepRight$1({
      from: this.voerka.sn
    }, message), options);
  },
  publishMessage(topic, message = {}, options = {}) {
    this._assertMaster();
    const { timeout = this.voerka.sessionTimeout } = options;
    if (message.sid === true) {
      message.sid = this._sid++;
    }
    if (message.tid === true) {
      message.tid = this.genTid();
    }
    topic = this.getTopic(topic, message);
    if (isNaN(message.sid) || Number(message.sid) === 0) {
      return this.publish(topic, message, options);
    } else {
      return new Promise((r, j) => {
        let getAnswer = false;
        let pid;
        const subscription = this.answerObservable.subscribe((data) => {
          const answer = data.message || {};
          if (String(answer.sid) === String(message.sid) && !getAnswer) {
            getAnswer = true;
            subscription.unsubscribe();
            pid && clearTimeout(pid);
            r(answer);
          }
        });
        pid = setTimeout(() => {
          subscription && subscription.unsubscribe();
          if (!getAnswer) {
            getAnswer = true;
            j(new Error("Timeout"));
          }
        }, timeout);
        this.publish(topic, message, options);
      });
    }
  },
  postRegister(message = {}) {
  },
  postNotify(message = {}) {
  },
  postAlarm(message = {}, payload = {}, options = {}) {
    const topic = message.group ? TOPICS.ALARMS_GROUP : TOPICS.ALARMS;
    return this.publishMessage(topic, this.defineMessage(__spreadProps(__spreadValues({}, message), {
      type: MESSAGE_TYPE.ALARMS,
      payload
    })), options);
  },
  postEvent(message = {}, payload = {}, options = {}) {
    const topic = payload.code === EVENT_CODE.DEVICE_STATUS_CHANGED ? message.group ? TOPICS.EVENTS_STATUS_GROUP : TOPICS.EVENTS_STATUS : message.group ? TOPICS.EVENTS_GROUP : TOPICS.EVENTS;
    return this.publishMessage(topic, this.defineMessage(__spreadProps(__spreadValues({}, message), {
      type: MESSAGE_TYPE.EVENTS,
      payload
    })), options);
  },
  postMessage(message = {}) {
  },
  postData(message = {}) {
  },
  postQuery(message = {}) {
  },
  postBroadcast(message = {}) {
  },
  postAnswer(message = {}, payload = {}, options = {}) {
    return this.publish(this.getTopic(TOPICS.ANSWER, message), this.defineMessage(__spreadProps(__spreadValues({}, message), {
      type: MESSAGE_TYPE.ANSWER,
      payload
    })), options);
  },
  postAction(message = {}, payload = {}, options = {}) {
    return this.publishMessage(TOPICS.ACTIONS, this.defineMessage(__spreadProps(__spreadValues({}, message), {
      type: MESSAGE_TYPE.ACTIONS,
      payload
    })), options);
  },
  postAttrs(message = {}, payload = {}, options) {
    return this.publishMessage(TOPICS.ATTRS, this.defineMessage(__spreadProps(__spreadValues({}, message), {
      type: MESSAGE_TYPE.ATTRS,
      payload
    })), options);
  },
  postResEvent(code, info = {}, res = {}, message = {}, options) {
    const { type: type3, sub_type, sub_id } = info;
    const topic = sub_type && sub_id ? TOPICS.RESOURCE_SUB : TOPICS.RESOURCE;
    return this.publishMessage(topic.toVoerkaTopic(info), this.defineMessage(__spreadProps(__spreadValues({}, message), {
      type: MESSAGE_TYPE.EVENTS,
      payload: {
        code,
        resType: sub_type || type3,
        res
      }
    })), options);
  },
  postResCreated(...params) {
    return this.postResEvent(EVENT_CODE.RESOURCE_CREATED, ...params);
  },
  postResUpdated(...params) {
    return this.postResEvent(EVENT_CODE.RESOURCE_UPDATED, ...params);
  },
  postResDeleted(...params) {
    return this.postResEvent(EVENT_CODE.RESOURCE_DELETED, ...params);
  },
  upgradeDevice(target, data = {}) {
    return this.postAction({ to: target, sid: true }, __spreadValues({ action: "upgrade" }, data));
  },
  setDeviceAttrs(target, data = {}) {
    return this.postAttrs({ to: target, sid: true }, data);
  },
  setTransactionProgress(message, _a = {}, options) {
    var _b = _a, { progress = 10, result = TRANSACTION_RESULT.HANDLING } = _b, data = __objRest(_b, ["progress", "result"]);
    return this.postEvent(message, __spreadProps(__spreadValues({}, data), {
      code: EVENT_CODE.DEVICE_TRANS_PROGRESS,
      progress,
      result
    }), options);
  },
  handleAlarm(message, _c = {}, options) {
    var _d = _c, { remarks = "", result = TRANSACTION_RESULT.NOT_SERVICED } = _d, data = __objRest(_d, ["remarks", "result"]);
    result = result >= TRANSACTION_RESULT.COMPLETED ? result : TRANSACTION_RESULT.COMPLETED;
    const code = Number(result) % 2 === 1 ? EVENT_CODE.DEVICE_ALARM_CANCELLED : EVENT_CODE.DEVICE_ALARM_HANDLED;
    return this.postEvent(message, __spreadProps(__spreadValues({}, data), {
      code,
      remarks,
      result
    }), options);
  },
  genTid() {
    return this._tidGenerator.gen().toString();
  },
  getTopic(topic, message = {}) {
    const { to, domain, group, tid } = message;
    return topic.toVoerkaTopic(mergeWithValue(this.voerka, { sn: to, domain, group: trim(group, "/"), tid }));
  }
};
const _g = globalThis || window || global;
const MASTER_CLIENT = "master";
function TempMessager(name2) {
  this._client = this._clients[name2] || this._master;
}
const pipeWhileNotNil = pipeWith$1((f, res) => isNil$1(res) ? res : f(res));
class VoerkaMessager {
  constructor(options = {}) {
    this._clients = {};
    this._master = null;
    this._client = null;
    this._clientOptions = {};
    this._statusSubject = new Subject();
    this._interceptors = [
      (data) => {
        data.message = serialize(data.message, { pack: this.msgpack });
        return data;
      },
      this._statistics
    ];
    this._options = mergeDeepRight$1({
      name: "vmessager",
      MQTT: MqttImpl,
      autoConnect: true,
      base: {
        msgpack: false
      },
      clients: {},
      master: {
        onConection: null,
        defineInSubject: null,
        defineOutSubject: null
      }
    }, options);
    if (this._options.autoConnect) {
      this.connect();
    }
    TempMessager.prototype = this;
    TempMessager.prototype.constructor = TempMessager;
    const name2 = this._options.name;
    if (name2) {
      _g[name2] = this;
    }
    _logger.info(name2, "created");
  }
  get MQTT() {
    return this._options.MQTT;
  }
  get name() {
    var _a;
    return (_a = this._client) == null ? void 0 : _a._v_name;
  }
  get status() {
    var _a;
    return (_a = this._client) == null ? void 0 : _a._v_status;
  }
  get isMaster() {
    return this.name === MASTER_CLIENT;
  }
  get connected() {
    var _a;
    return (_a = this._client) == null ? void 0 : _a.connected;
  }
  get reconnecting() {
    var _a;
    return (_a = this._client) == null ? void 0 : _a.reconnecting;
  }
  get url() {
    var _a;
    return (_a = this._client) == null ? void 0 : _a.options.url;
  }
  get clientId() {
    var _a;
    return (_a = this._client) == null ? void 0 : _a.options.clientId;
  }
  get msgpack() {
    var _a;
    return (_a = this._client) == null ? void 0 : _a.options.msgpack;
  }
  get subscriptions() {
    var _a;
    const subscriptions = ((_a = this._client) == null ? void 0 : _a._resubscribeTopics) || {};
    return Object.keys(subscriptions);
  }
  _assert(check, message = "") {
    if (typeof check === "function") {
      if (!check()) {
        throw new Error(message);
      }
    } else {
      if (!check) {
        throw new Error(message);
      }
    }
  }
  _assertMaster() {
    this._assert(() => !(this instanceof TempMessager), "Should use in master client");
  }
  _assertClient() {
    this._assert(() => this._client, "Client has ended");
  }
  _setup() {
    const setups = Object.values(VoerkaMessager.setups);
    setups.forEach((setup2) => {
      setup2.call(this);
    });
  }
  use(name2, options) {
    this._assertMaster();
    return new TempMessager(name2, options);
  }
  _createMessageOutSubject() {
    return new Subject().pipe(share());
  }
  _createMessageInSubject() {
    return new Subject();
  }
  _createClientAndWatch(name2, options, baseClient) {
    const { defineInSubject, defineOutSubject, onConection } = options;
    this._assert(() => options.url && typeof options.url === "string", "Client require url");
    _logger.info("messager options", options);
    const client = this.MQTT.connect(options.url, options);
    client._v_options = options;
    client._v_name = name2;
    client._v_status = "";
    if (baseClient) {
      client._v_info = baseClient._v_info;
      client._v_out_subject = baseClient._v_out_subject;
      baseClient._v_out_subscription && baseClient._v_out_subscription.unsubscribe();
      client._v_out_subscription = client._v_out_subject.subscribe((data) => {
        const { topic, message, options: options2, callback } = data;
        client.publish(topic, message, options2, callback);
      });
      client._v_subject = baseClient._v_subject;
      client._v_observables = baseClient._v_observables;
    } else {
      client._v_info = {};
      let outSubject = this._createMessageOutSubject();
      if (defineOutSubject) {
        outSubject = defineOutSubject(outSubject);
      }
      client._v_out_subject = outSubject;
      client._v_out_subscription = outSubject.subscribe((data) => {
        const { topic, message, options: options2, callback } = data;
        client.publish(topic, message, options2, callback);
      });
      let subject = this._createMessageInSubject();
      if (defineInSubject) {
        subject = defineInSubject(subject);
      }
      client._v_subject = subject;
      client._v_observables = [];
    }
    const setStatus = (status, error) => {
      if (client._v_ended) {
        return;
      }
      client._v_status = status;
      this._statusSubject.next({ name: name2, status, error });
      _logger.info(name2, status, error);
    };
    client.on("connect", (packet) => {
      setStatus("connect");
    });
    client.on("disconnect", (packet) => {
      setStatus("disconnect");
    });
    client.on("reconnect", () => {
      setStatus("reconnect");
    });
    client.on("close", () => {
      setStatus("close");
    });
    client.on("error", (error) => {
      setStatus("error", error.message);
    });
    client.on("offline", (error) => {
      setStatus("offline");
    });
    client.on("message", (topic, payload, packet) => {
      client._v_subject.next({
        topic,
        message: deserialize(payload),
        packet
      });
    });
    if (name2 === MASTER_CLIENT) {
      this._master = client;
      this._client = client;
    }
    this._setup();
    onConection && onConection(this);
    return client;
  }
  _statistics(data) {
    return data;
  }
  update(options = {}) {
    options = mergeDeepRight$1(this._client._v_options, options);
    const keyPick = pick$1(["url", "clientId"]);
    const keyUpdated = !equals$1(keyPick(options), keyPick(this._client._v_options));
    this._client._v_options = options;
    if (keyUpdated) {
      this.end(false);
      this._createClientAndWatch(this.name, options, this._client);
    }
    Object.values(VoerkaMessager.updates).forEach((update) => {
      update && update.call(this, options);
    });
  }
  _getClientOptions(name2) {
    const { base, master, clients } = this._options;
    let options;
    if (!name2 || name2 === MASTER_CLIENT) {
      options = mergeDeepRight$1(base, master);
    } else {
      options = mergeDeepRight$1(base, clients[name2] || {});
    }
    return options;
  }
  connect() {
    this._assertMaster();
    this._createClientAndWatch(MASTER_CLIENT, this._getClientOptions(MASTER_CLIENT));
  }
  end(clean = true, ...params) {
    var _a, _b;
    this._assertClient();
    if (clean) {
      (_a = this._client._v_subject) == null ? void 0 : _a.complete();
      (_b = this._client._v_out_subject) == null ? void 0 : _b.complete();
    }
    const res = this._client.end(...params);
    this._clientOptions[this.name] = this._client._v_options;
    this._client._v_ended = true;
    return res;
  }
  on(...params) {
    this._assertClient();
    return this._client.on(...params);
  }
  publish() {
    this._assertClient();
    let data = Args([
      { topic: Args.STRING | Args.Required },
      { message: Args.OBJECT | Args.Required },
      { options: Args.OBJECT | Args.Optional },
      { callback: Args.FUNCTION | Args.Optional }
    ], arguments);
    const { topic, message, options = {} } = data;
    const { straight = false } = options;
    if (straight) {
      this._client._v_subject.next({
        topic,
        message,
        packet: null
      });
    }
    data = pipeWhileNotNil(this._interceptors)(data);
    this._client._v_out_subject.next(data);
    return { topic, message };
  }
  onMessage(observer) {
    this._assertClient();
    if (typeof observer === "function") {
      observer = {
        next: observer
      };
    }
    return this._client._v_subject.subscribe(observer);
  }
  onStatus(observer) {
    this._assertClient();
    if (typeof observer === "function") {
      observer = {
        next: observer
      };
    }
    return this._statusSubject.subscribe(observer);
  }
  getObservable(operators = []) {
    this._assertClient();
    if (operators && operators.length) {
      const observable2 = this._client._v_subject.pipe(...operators);
      this._client._v_observables.push(observable2);
      return observable2;
    }
  }
  getTopicObservable(tp = "") {
    if (!tp) {
      return;
    }
    let filterFunc;
    if (typeof tp === "string") {
      filterFunc = ({ topic }) => topic.endsWith(tp);
    } else if (tp instanceof RegExp) {
      filterFunc = ({ topic }) => tp.test(topic);
    } else if (typeof tp === "function") {
      filterFunc = ({ topic }) => tp(topic);
    }
    return this.getObservable([filter(filterFunc)]);
  }
  getMessageObservable(func = () => true) {
    const filterFunc = ({ message }) => func(message);
    return this.getObservable([filter(filterFunc)]);
  }
  subscribe(...params) {
    this._assertClient();
    return this._client.subscribe(...params);
  }
  unsubscribe(...params) {
    this._assertClient();
    return this._client.unsubscribe(...params);
  }
  reconnect(...params) {
    this._assertClient();
    return this._client.reconnect(...params);
  }
  useInterceptors(interceptor) {
    _logger.warn('"useInterceptors" has deprecated at ^2.4.6 !!! Plase use "defineOutSubject" instead.');
    if (typeof interceptor === "function") {
      this._interceptors.unshift(interceptor);
    }
  }
}
VoerkaMessager.prototype._createMessageInSubject._replaceable = true;
VoerkaMessager.setups = {};
VoerkaMessager.updates = {};
VoerkaMessager.use = function(plugin = {}) {
  const _a = plugin, { name: name2, setup: setup2, update } = _a, otherFuncs = __objRest(_a, ["name", "setup", "update"]);
  if (!name2 || VoerkaMessager.setups[name2]) {
    return;
  }
  VoerkaMessager.setups[name2] = setup2;
  VoerkaMessager.updates[name2] = update;
  Object.keys(otherFuncs).forEach((key) => {
    if (!VoerkaMessager.prototype.hasOwnProperty(key) || VoerkaMessager.prototype[key]._replaceable) {
      VoerkaMessager.prototype[key] = otherFuncs[key];
    }
  });
};
VoerkaMessager.use(VoerkaPlugin);
export { ALARM_CODE, ALARM_LEVEL, EVENT_CODE, MESSAGE_TYPE, RESPONSE_CODE, TOPICS, TRANSACTION_RESULT, TRANSACTION_STATUS, VoerkaMessager as default, defineMessage, getMessageId };
