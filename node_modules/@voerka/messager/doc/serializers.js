const msgpack = require('msgpack5')();
const vstruct = require('varstruct');
const JSONbig = require('json-bigint')({ useNativeBigInt: true });
const ajv = new (require('ajv'))({ allErrors: true, jsonPointers: true, useDefaults: true });
require('ajv-errors')(ajv);
function isJson(data, spaceLimit = Infinity) {
    let spaceSymbols, braceLeft, braceRight, bracketLeft, bracketRight;
    if (data instanceof Buffer) {
        spaceSymbols = [0x0a, 0x0d, 0x20];
        braceLeft = 0x7b; braceRight = 0x7d;
        bracketLeft = 0x5b; bracketRight = 0x5d;
    } else if (typeof data === 'string') {
        spaceSymbols = ['\n', '\r', ' '];
        braceLeft = '{'; braceRight = '}';
        bracketLeft = '['; bracketRight = ']';
    } else {
        return false;
    }
    let len = data.length, leftPass = false, rightPass = false;
    for (let i = len; i-- && i < spaceLimit;) {
        if (!rightPass) {
            if (spaceSymbols.indexOf(data[i]) === -1) {
                if (data[i] === braceRight || data[i] === bracketRight) rightPass = true;
                else return false;
            }
        }
        if (!leftPass) {
            let j = len - i - 1;
            if (spaceSymbols.indexOf(data[j]) === -1) {
                if (data[j] === braceLeft || data[j] === bracketLeft) leftPass = true;
                else return false;
            }
        }
    }
    return leftPass && rightPass;
}

class MessageBase {
    static get sidKey() {
        return true;  // especifica el nombre de la clave del ID de sesión para este mensaje. Si se establece como 'sid' o true, el nombre de la clave del ID de sesión será sid. Si se establece como false, no incluirá ID de sesión.
    }
    static get responseMessageClass() {
        return false;  // especifica el tipo de mensaje de respuesta correspondiente a este mensaje. false o vacío = sin restricción. Aplicable para respuestas de mensajes cuando se transmite con ID de sesión duplicado sin distinción
    }
    static get struct() {
        return [];
    }
    static get schema() {
        return {};
    }
    constructor(body={}) {
        let inValidMessage = this.constructor.validate(body);
        if (inValidMessage) throw new Error(inValidMessage);
        this._bodyHandler = {
            set: (obj, prop, value) => {
                this[prop] = value;
                obj[prop] = value;
                return true;
            },
            // deleteProperty(target, prop) {
            //     delete this[prop];
            //     delete target[prop];
            //     return true;
            // }
        };
        this.body = body || {};
        this.struct = vstruct(this.constructor.struct);
    }
    get body() {
        for (let key in this._body) {
            if (!this.hasOwnProperty(key)) delete this._body[key];
        }
        return this._body;
    }
    set body(value) {
        for (let key in this._body) {
            delete this[key];
        }
        this._body = new Proxy(value, this._bodyHandler);
        for (let key in value) {
            this[key] = value[key];
        }
    }
    toString() {
        return JSONbig.stringify(this.body);
    }
    toJson() {
        return this.body;
    }
    toBuffer() {
        return Buffer.from(JSONbig.stringify(this.body));
    }
    toStructBuffer() {
        return this.constructor.customStructEncoder(this.body) || this.struct.encode(this.body);
    }
    toMsgPack() {
        return msgpack.encode(this.body);
    }
    static validate(data) {
        let dataValidate = ajv.compile(this.schema);
        let isValid = dataValidate(data);
        if (!isValid) {
            return `${dataValidate.errors[0].dataPath} ${dataValidate.errors[0].message}`;
        }
    }

    static customStructEncoder(data) {}
    static customStructDecoder(data) {}
}

// Serializa los datos a MsgPack o Buffer no estructurado
function msgPackSerialize(message, options={ debug: false }) {
	if (options.debug) {  // a Buffer no estructurado
        return message.toBuffer ? message.toBuffer() : message;
    } else {  // MsgPack
        return message.toMsgPack();
    }
}

// Deserializa MsgPack o JSON String o JSON Buffer
function msgPackDeserialize(data, options={ debug: false }) {
	if (!data || data.length === 0) return {};
    let unpacked;
	let err;
	if (isJson(data)) {
		// Independientemente del debug, primero intenta decodificar como JSON
		try {
		    unpacked = JSONbig.parse(data);
        } catch (e) {
		    err = e;
        }
	} else {
		try {  // De lo contrario, intenta decodificar con msgpack
			unpacked = msgpack.decode(data);
			// Y después intenta convertirlo a JSON
			try {
				unpacked = JSONbig.parse(unpacked);
			} catch (e) {/* Si no se puede convertir a JSON, mantiene el formato original */}
		} catch (e) {  // Si falla, lanza error
			err = e;
		}
	}
	if (err) {
		throw err;
	}
	if (unpacked) {
	    unpacked.__sidKey__ = MessageBase.sidKey;
	    unpacked.__msgClass__ = MessageBase;
    }
	return unpacked;
}

// Serializa los datos a Buffer estructurado o Buffer no estructurado
function msgStructBufferSerialize(message) {
	return message.toStructBuffer();
}

// Deserializa MsgPack o JSON String o JSON Buffer
function msgStructBufferDeserialize(msgClass, data) {
    if (!msgClass) return;
    let msgClasses = Array.isArray(msgClass) ? msgClass : [msgClass];
	let unpacked;
	let err;
	if (isJson(data)) {
		try {
		    unpacked = JSONbig.parse(data);
        } catch (e) {
		    err = e;
        }
	} else {
		for (let i in msgClasses) {
		    try {  // De lo contrario, intenta decodificar con struct
                unpacked = msgClass.customStructDecoder(data) || vstruct(msgClasses[i].struct).decode(data);
                // Y después intenta convertirlo a JSON
                try {
                    unpacked = JSONbig.parse(unpacked);
                } catch (e) {/* Si no se puede convertir a JSON, mantiene el formato original */}
                break;
            } catch (e) {  // Si falla, lanza error
                err = e;
            }
        }
	}
	if (err) {
		throw err;
	}
	if (unpacked) {
	    unpacked.__sidKey__ = msgClass.sidKey;
	    unpacked.__msgClass__ = msgClass;
    }
	return unpacked;
}

module.exports = {
    isJson,
    MessageBase,
    msgPackSerialize,
    msgPackDeserialize,
    msgStructBufferSerialize,
    msgStructBufferDeserialize
};