import MqttImpl from 'mqtt/dist/mqtt'
import { mergeDeepRight, pipeWith, isNil, equals, pick } from 'ramda'
import Args from 'args-js'
import { Subject } from 'rxjs'
import { filter, share } from 'rxjs/operators'
import { serialize, deserialize } from './serializer'
import _logger from './logger'
import VoerkaPlugin from './voerka'
export * from './voerka/message'

// 全局对象
const _g = globalThis || window || global

const MASTER_CLIENT = 'master'

/**
 * 临时Messager类
 * 用于作为VoerkaMessager的子类，方便单独信道使用
 * @param {*} name
 */
function TempMessager(name) {
	// 当前的客户端
	this._client = this._clients[name] || this._master
}

// 过滤掉null于undefined返回结果的过滤器函数
const pipeWhileNotNil = pipeWith((f, res) => (isNil(res) ? res : f(res)))

/**
 * VoerkaMessager类
 *
 * 新尝试：
 * 每个实例接发消息都用this._client，然后可以使用use方法来新建一个子类实例，替换掉子类实例的_client实现从不同端接收发送消息
 * 由一个VoerkaMessager统一维护所有的mqtt连接，开放部分逻辑给TempMessager，TempMessager可以用来切换到不同的连接
 * 缺点：没有理解很难维护，而且有些地方难以个性化，比如不同的信道要用不同的编解码
 *
 * _v_ 表示寄生于mqtt client实例上的VoerkaMessager需要跟随维护的数据
 */
export default class VoerkaMessager {
	constructor(options = {}) {
		// 存储当前的mqtt.Clients实例，name-client映射
		this._clients = {}

		// 当前主客户端
		this._master = null
		// 当前客户端，即当前用于操作的客户端，配合TempMessager使用
		this._client = null
		// 保存当前的客户端的options，方便end之后重新创建
		this._clientOptions = {}

		// 状态subject
		this._statusSubject = new Subject()

		// 拦截器
		// 拦截器方法必须是一元函数
		this._interceptors = [
			data => {
				data.message = serialize(data.message, { pack: this.msgpack })
				return data
			},
			this._statistics
		]

		// 参数
		this._options = mergeDeepRight(
			{
				name: 'vmessager',
				MQTT: MqttImpl, // mqtt实现，默认浏览器端
				autoConnect: true, // 自动连接
				base: {
					// 基本配置
					msgpack: false // 是否压缩消息发送，各个信道可以根据需求配置
				},
				clients: {}, // 多客户端，多信道配置, name: options
				master: {
					onConection: null, // 连接创建时触发，建议将订阅类的全部写道这个方法内
					defineInSubject: null, // 进消息 subject封装方法
					defineOutSubject: null // 出消息 subject封装方法
					// 主客户端配置, 即mqtt client参数
				}
			},
			options
		)

		// 判断是否自动连接
		if (this._options.autoConnect) {
			this.connect()
		}

		// 临时messager固定继承this
		TempMessager.prototype = this
		TempMessager.prototype.constructor = TempMessager

		// 全局注册
		const name = this._options.name
		if (name) {
			_g[name] = this
		}
		// 打印日志
		_logger.info(name, 'created')
	}

	// Mqtt实现（浏览器端/nodejs）
	get MQTT() {
		return this._options.MQTT
	}

	// 当前messager的名称
	get name() {
		return this._client?._v_name
	}

	get status() {
		return this._client?._v_status
	}

	get isMaster() {
		return this.name === MASTER_CLIENT
	}

	get connected() {
		return this._client?.connected
	}

	get reconnecting() {
		return this._client?.reconnecting
	}

	get url() {
		return this._client?.options.url
	}

	get clientId() {
		return this._client?.options.clientId
	}

	get msgpack() {
		return this._client?.options.msgpack
	}

	get subscriptions() {
		const subscriptions = this._client?._resubscribeTopics || {}
		return Object.keys(subscriptions)
	}

	// 断言
	_assert(check, message = '') {
		if (typeof check === 'function') {
			if (!check()) {
				throw new Error(message)
			}
		} else {
			if (!check) {
				throw new Error(message)
			}
		}
	}

	// 断言当前客户端为主客户端
	_assertMaster() {
		this._assert(() => !(this instanceof TempMessager), 'Should use in master client')
	}

	// 断言当前客户端未结束
	_assertClient() {
		this._assert(() => this._client, 'Client has ended')
	}

	// 初始化所有插件
	_setup() {
		const setups = Object.values(VoerkaMessager.setups)
		setups.forEach(setup => {
			setup.call(this)
		})
	}

	/**
	 * 使用临时messager
	 * 多用于功能信道使用
	 * @param {*} name
	 * @param {*} options
	 * @returns
	 */
	use(name, options) {
		this._assertMaster()
		return new TempMessager(name, options)
	}

	// 创建消息发送主题
	// 所有publish都会从该主题.next，然后发送出去
	_createMessageOutSubject() {
		// 直接起手share
		return new Subject().pipe(share())
	}

	// 创建消息接收主题
	_createMessageInSubject() {
		// mqtt固有问题：订阅重叠就会导致一个消息收到多次
		// 这一步交给业务自己去做！！！
		return new Subject()
	}

	/**
	 *
	 * 创建mqtt客户端，并监听客户端，记录信息
	 *
	 * @param {*} name
	 * @param {*} options
	 * @param {*} baseClient 原本信道，如果没有代表全新创建，如果有代表只是重新创建client，之前client其他东西全部转移到这个client上
	 * @returns
	 */
	_createClientAndWatch(name, options, baseClient) {
		const { defineInSubject, defineOutSubject, onConection } = options
		// 断言是否由连接地址
		this._assert(() => options.url && typeof options.url === 'string', 'Client require url')
		// 连接
		_logger.info('messager options', options)
		const client = this.MQTT.connect(options.url, options)

		// 参数
		client._v_options = options
		// 名称
		client._v_name = name
		// 状态
		client._v_status = ''

		// TODO: 这种做法是糟糕的，
		// 应该再创建一个容器来扩展才对，可能当时考虑的不想把client放在太深吧

		if (baseClient) {
			client._v_info = baseClient._v_info
			client._v_out_subject = baseClient._v_out_subject
			// 清理之前的订阅，避免内存泄漏，此处这种代码结构非常糟糕
			baseClient._v_out_subscription && baseClient._v_out_subscription.unsubscribe()
			// 重新订阅
			client._v_out_subscription = client._v_out_subject.subscribe(data => {
				const { topic, message, options, callback } = data
				// 就是因为这个client直接引用，1.可能导致内存泄漏 2.手动管理麻烦，需要自行注意
				client.publish(topic, message, options, callback)
			})

			client._v_subject = baseClient._v_subject
			client._v_observables = baseClient._v_observables
		} else {
			client._v_info = {}
			// 对外发送的主题
			let outSubject = this._createMessageOutSubject()
			if (defineOutSubject) {
				outSubject = defineOutSubject(outSubject)
			}
			client._v_out_subject = outSubject
			client._v_out_subscription = outSubject.subscribe(data => {
				const { topic, message, options, callback } = data
				client.publish(topic, message, options, callback)
			})

			// 消息主题
			// TODO: 开放subject参数配置
			let subject = this._createMessageInSubject()
			if (defineInSubject) {
				subject = defineInSubject(subject)
			}
			client._v_subject = subject
			// 用户额外需求的可观察对象列表，从主题那边衍生出来的
			client._v_observables = []
		}

		// 更新状态
		const setStatus = (status, error) => {
			if (client._v_ended) {
				return
			}
			client._v_status = status
			// 所有信道共用一个status发布器
			this._statusSubject.next({ name, status, error })
			_logger.info(name, status, error)
		}

		// 信道连接
		client.on('connect', packet => {
			setStatus('connect')
		})
		// 信道断开连接
		client.on('disconnect', packet => {
			setStatus('disconnect')
		})
		// 信道重新连接
		client.on('reconnect', () => {
			setStatus('reconnect')
		})
		// 信道关闭
		client.on('close', () => {
			setStatus('close')
		})
		// 信道发生错误
		client.on('error', error => {
			setStatus('error', error.message)
		})
		// 信道离线
		client.on('offline', error => {
			setStatus('offline')
		})

		// 消息接收
		client.on('message', (topic, payload, packet) => {
			client._v_subject.next({
				topic,
				message: deserialize(payload),
				packet
			})
		})

		// 保存
		// TODO: 扩充其他信道
		if (name === MASTER_CLIENT) {
			this._master = client
			// 保证在主信道下，onConnection可以直接使用大部分方法
			// 如果是其他信道，必须通过messager.use再次切换到真正的信道上
			this._client = client
		}

		// 初始化插件
		this._setup()

		// 创建连接后触发回调
		onConection && onConection(this)

		return client
	}

	// 统计发送消息情况
	_statistics(data) {
		// console.log('开始统计..............')
		return data
	}

	/**
	 * 更新某个信道的连接，不是更新messager
	 * @param {*} options
	 */
	update(options = {}) {
		// 获取新的参数
		options = mergeDeepRight(this._client._v_options, options)
		// 判断是否更改了关键参数【会引起连接重新创建】
		const keyPick = pick(['url', 'clientId'])
		const keyUpdated = !equals(keyPick(options), keyPick(this._client._v_options))
		// 替换options
		this._client._v_options = options

		// 涉及到连接重置的更改
		if (keyUpdated) {
			// 保留模式关闭信道，准重新创建信道
			this.end(false)
			// 重新创建client
			this._createClientAndWatch(this.name, options, this._client)
		}

		// 通知插件参数更新
		Object.values(VoerkaMessager.updates).forEach(update => {
			update && update.call(this, options)
		})
	}

	// 获取客户端参数
	_getClientOptions(name) {
		const { base, master, clients } = this._options
		let options
		if (!name || name === MASTER_CLIENT) {
			options = mergeDeepRight(base, master)
		} else {
			options = mergeDeepRight(base, clients[name] || {})
		}
		return options
	}

	/**
	 * 创建连接
	 * 将所有连接在此处一并创建，备用连接、扩展连接
	 * 注意：有自动连接的情况则必然不能使用tempMessager里面的参数
	 */
	connect() {
		this._assertMaster()
		// TODO: 目前先只做主客户端的连接，暂时没有处理其他clients
		this._createClientAndWatch(MASTER_CLIENT, this._getClientOptions(MASTER_CLIENT))
	}

	// 结束当前客户端的连接
	end(clean = true, ...params) {
		this._assertClient()
		// 干净模式下，彻底关闭跟随信道的subject
		// 保留模式下，即可能新的client会替代之前的client，则为了防止之前的观察订阅失效，需要沿用之前的subject，只是mqtt client被替代了
		if (clean) {
			// 结束信道消息相关的subject
			this._client._v_subject?.complete()
			this._client._v_out_subject?.complete()
		}
		// 结束mqtt客户端
		const res = this._client.end(...params)
		// 保存当前客户端参数，后面如果允许某个连接end之后重启，那么就会用到
		this._clientOptions[this.name] = this._client._v_options
		// 标记客户端主动关闭
		this._client._v_ended = true
		return res
	}

	// 监听当前客户端的消息
	on(...params) {
		this._assertClient()
		return this._client.on(...params)
	}

	// 发布消息
	publish() {
		this._assertClient()
		// 标准mqtt.Client#publish()
		let data = Args(
			[
				{ topic: Args.STRING | Args.Required },
				{ message: Args.OBJECT | Args.Required },
				{ options: Args.OBJECT | Args.Optional },
				{ callback: Args.FUNCTION | Args.Optional }
			],
			arguments
		)
		const { topic, message, options = {} } = data
		const { straight = false } = options
		// 直发，表示消息直接进入接收
		if (straight) {
			this._client._v_subject.next({
				topic,
				message: message,
				packet: null
			})
		}

		// 发送
		// 扔到subject中
		data = pipeWhileNotNil(this._interceptors)(data)
		this._client._v_out_subject.next(data)

		return { topic, message }
	}

	// 接收消息
	onMessage(observer) {
		this._assertClient()
		if (typeof observer === 'function') {
			observer = {
				next: observer
			}
		}
		// 返回订阅对象，以供取消订阅 xx.unsubscribe()
		return this._client._v_subject.subscribe(observer)
	}

	// 订阅当前client状态变化
	onStatus(observer) {
		this._assertClient()
		if (typeof observer === 'function') {
			observer = {
				next: observer
			}
		}
		// 返回订阅对象，以供取消订阅 xx.unsubscribe()
		return this._statusSubject.subscribe(observer)
	}

	// 创建自定义观察对象
	getObservable(operators = []) {
		this._assertClient()
		if (operators && operators.length) {
			const observable = this._client._v_subject.pipe(...operators)
			// 保存起来，虽然没什么用
			this._client._v_observables.push(observable)
			return observable
		}
	}

	// 创建一个“只观察某个话题下的可观察对象”
	// 方便用户快速订阅某些主题下的消息
	getTopicObservable(tp = '') {
		if (!tp) {
			return
		}
		let filterFunc
		// 字符串
		if (typeof tp === 'string') {
			filterFunc = ({ topic }) => topic.endsWith(tp)
		} else if (tp instanceof RegExp) {
			// 正则表达式
			filterFunc = ({ topic }) => tp.test(topic)
		} else if (typeof tp === 'function') {
			// 方法
			filterFunc = ({ topic }) => tp(topic)
		}
		return this.getObservable([filter(filterFunc)])
	}

	// 获取消息可观察对象
	getMessageObservable(func = () => true) {
		const filterFunc = ({ message }) => func(message)
		return this.getObservable([filter(filterFunc)])
	}

	// 订阅主题
	subscribe(...params) {
		this._assertClient()
		return this._client.subscribe(...params)
	}

	// 取消订阅主题
	unsubscribe(...params) {
		this._assertClient()
		return this._client.unsubscribe(...params)
	}

	// 重连
	reconnect(...params) {
		this._assertClient()
		return this._client.reconnect(...params)
	}

	/**
	 * 发布消息前拦截
	 * 1. 暂时简单使用数组实现，无法取消
	 * 2. 只有发送前拦截，无接收后拦截，因为那样跟接收的实现是一样的
	 * 3. 为了简单起见，所有客户端使用一个拦截，在内部自行判断拦截来源
	 * @param {*} interceptor
	 * @deprecated 废弃，选中defineOutSubject实现
	 */
	useInterceptors(interceptor) {
		_logger.warn('"useInterceptors" has deprecated at ^2.4.6 !!! Plase use "defineOutSubject" instead.')
		if (typeof interceptor === 'function') {
			this._interceptors.unshift(interceptor)
		}
	}
}

// 定义可替代方法
VoerkaMessager.prototype._createMessageInSubject._replaceable = true
// 实现插件机制
VoerkaMessager.setups = {}
VoerkaMessager.updates = {}
VoerkaMessager.use = function (plugin = {}) {
	const { name, setup, update, ...otherFuncs } = plugin
	if (!name || VoerkaMessager.setups[name]) {
		// 没有名称或者已经注册过，直接返回
		return
	}
	// 将初始化方法添加到池中
	VoerkaMessager.setups[name] = setup
	// 更新方法添加到池中
	VoerkaMessager.updates[name] = update
	// 混入
	Object.keys(otherFuncs).forEach(key => {
		if (!VoerkaMessager.prototype.hasOwnProperty(key) || VoerkaMessager.prototype[key]._replaceable) {
			VoerkaMessager.prototype[key] = otherFuncs[key]
		}
	})
}

// 预设voerka业务插件
VoerkaMessager.use(VoerkaPlugin)
