import MqttImpl from 'mqtt/dist/mqtt'
import { mergeDeepRight, pipeWith, isNil, equals, pick } from 'ramda'
import Args from 'args-js'
import { Subject } from 'rxjs'
import { filter, share } from 'rxjs/operators'
import { serialize, deserialize } from './serializer'
import _logger from './logger'
import VoerkaPlugin from './voerka'
export * from './voerka/message'

// objeto global
const _g = globalThis || window || global

const MASTER_CLIENT = 'master'

/**
 * Clase Messager temporal
 * Se usa como subclase de VoerkaMessager, facilita el uso de canales individuales
 * @param {*} name
 */
function TempMessager(name) {
	// cliente actual
	this._client = this._clients[name] || this._master
}

// función de filtro que elimina resultados nulos e indefinidos
const pipeWhileNotNil = pipeWith((f, res) => (isNil(res) ? res : f(res)))

/**
 * Clase VoerkaMessager
 *
 * Nuevo enfoque:
 * Cada instancia usa this._client para enviar y recibir mensajes, y puede usar el método use para crear una nueva instancia de subclase,
 * reemplazando el _client de la subclase para implementar la recepción y envío de mensajes desde diferentes terminales.
 * Un VoerkaMessager mantiene todas las conexiones mqtt de manera unificada, exponiendo parte de la lógica a TempMessager,
 * que puede usarse para cambiar entre diferentes conexiones.
 * Desventajas: difícil de mantener sin una comprensión profunda, y algunas áreas son difíciles de personalizar,
 * como usar diferentes codificadores/decodificadores para diferentes canales.
 *
 * _v_ indica datos que VoerkaMessager necesita mantener junto con la instancia del cliente mqtt
 */
export default class VoerkaMessager {
	constructor(options = {}) {
		// almacena las instancias actuales de mqtt.Clients, mapeo nombre-cliente
		this._clients = {}

		// cliente principal actual
		this._master = null
		// cliente actual, es decir, el cliente que se usa para operaciones, se usa junto con TempMessager
		this._client = null
		// guarda las opciones del cliente actual, útil para recrear después de end
		this._clientOptions = {}

		// subject de estado
		this._statusSubject = new Subject()

		// interceptores
		// los métodos interceptores deben ser funciones unarias
		this._interceptors = [
			data => {
				data.message = serialize(data.message, { pack: this.msgpack })
				return data
			},
			this._statistics
		]

		// parámetros
		this._options = mergeDeepRight(
			{
				name: 'vmessager',
				MQTT: MqttImpl, // implementación mqtt, por defecto lado del navegador
				autoConnect: true, // conexión automática
				base: {
					// configuración básica
					msgpack: false // si se comprime el mensaje al enviar, cada canal puede configurar según necesidad
				},
				clients: {}, // configuración multi-cliente, multi-canal, name: options
				master: {
					onConection: null, // se dispara cuando se crea la conexión, se recomienda escribir todas las suscripciones en este método
					defineInSubject: null, // método de encapsulación del subject de entrada de mensajes
					defineOutSubject: null // método de encapsulación del subject de salida de mensajes
					// configuración del cliente principal, es decir, parámetros del cliente mqtt
				}
			},
			options
		)

		// determina si se conecta automáticamente
		if (this._options.autoConnect) {
			this.connect()
		}

		// TempMessager hereda fijo de this
		TempMessager.prototype = this
		TempMessager.prototype.constructor = TempMessager

		// registro global
		const name = this._options.name
		if (name) {
			_g[name] = this
		}
		// imprime log
		_logger.info(name, 'created')
	}

	// Implementación Mqtt (navegador/nodejs)
	get MQTT() {
		return this._options.MQTT
	}

	// nombre del messager actual
	get name() {
		return this._client?._v_name
	}

	get status() {
		return this._client?._v_status
	}

	get isMaster() {
		return this.name === MASTER_CLIENT
	}

	get connected() {
		return this._client?.connected
	}

	get reconnecting() {
		return this._client?.reconnecting
	}

	get url() {
		return this._client?.options.url
	}

	get clientId() {
		return this._client?.options.clientId
	}

	get msgpack() {
		return this._client?.options.msgpack
	}

	get subscriptions() {
		const subscriptions = this._client?._resubscribeTopics || {}
		return Object.keys(subscriptions)
	}

	// aserción
	_assert(check, message = '') {
		if (typeof check === 'function') {
			if (!check()) {
				throw new Error(message)
			}
		} else {
			if (!check) {
				throw new Error(message)
			}
		}
	}

	// asegura que el cliente actual es el cliente principal
	_assertMaster() {
		this._assert(() => !(this instanceof TempMessager), 'Should use in master client')
	}

	// asegura que el cliente actual no ha terminado
	_assertClient() {
		this._assert(() => this._client, 'Client has ended')
	}

	// inicializa todos los plugins
	_setup() {
		const setups = Object.values(VoerkaMessager.setups)
		setups.forEach(setup => {
			setup.call(this)
		})
	}

	/**
	 * Usa messager temporal
	 * Se usa principalmente para canales funcionales
	 * @param {*} name
	 * @param {*} options
	 * @returns
	 */
	use(name, options) {
		this._assertMaster()
		return new TempMessager(name, options)
	}

	// crea tema para envío de mensajes
	// todos los publish pasarán por .next de este tema antes de enviarse
	_createMessageOutSubject() {
		// comienza directamente con share
		return new Subject().pipe(share())
	}

	// crea tema para recepción de mensajes
	_createMessageInSubject() {
		// problema inherente de mqtt: suscripciones superpuestas causarán que un mensaje se reciba múltiples veces
		// ¡¡¡este paso se deja al negocio para que lo maneje!!!
		return new Subject()
	}

	/**
	 * Crea cliente mqtt y monitorea el cliente, registra información
	 *
	 * @param {*} name
	 * @param {*} options
	 * @param {*} baseClient canal original, si no existe significa creación nueva, si existe significa solo recrear client, todo lo demás del client anterior se transfiere a este client
	 * @returns
	 */
	_createClientAndWatch(name, options, baseClient) {
		const { defineInSubject, defineOutSubject, onConection } = options
		// asegura que existe dirección de conexión
		this._assert(() => options.url && typeof options.url === 'string', 'Client require url')
		// conexión
		_logger.info('messager options', options)
		const client = this.MQTT.connect(options.url, options)

		// parámetros
		client._v_options = options
		// nombre
		client._v_name = name
		// estado
		client._v_status = ''

		// TODO: este enfoque es malo,
		// debería crear un contenedor para extender, probablemente en ese momento se consideró no querer poner el client demasiado profundo

		if (baseClient) {
			client._v_info = baseClient._v_info
			client._v_out_subject = baseClient._v_out_subject
			// limpia suscripciones anteriores para evitar fugas de memoria, esta estructura de código aquí es muy mala
			baseClient._v_out_subscription && baseClient._v_out_subscription.unsubscribe()
			// vuelve a suscribir
			client._v_out_subscription = client._v_out_subject.subscribe(data => {
				const { topic, message, options, callback } = data
				// es por esta referencia directa al client que 1.puede causar fugas de memoria 2.gestión manual es molesta, hay que prestar atención
				client.publish(topic, message, options, callback)
			})

			client._v_subject = baseClient._v_subject
			client._v_observables = baseClient._v_observables
		} else {
			client._v_info = {}
			// tema para envío externo
			let outSubject = this._createMessageOutSubject()
			if (defineOutSubject) {
				outSubject = defineOutSubject(outSubject)
			}
			client._v_out_subject = outSubject
			client._v_out_subscription = outSubject.subscribe(data => {
				const { topic, message, options, callback } = data
				client.publish(topic, message, options, callback)
			})

			// tema de mensajes
			// TODO: abrir configuración de parámetros subject
			let subject = this._createMessageInSubject()
			if (defineInSubject) {
				subject = defineInSubject(subject)
			}
			client._v_subject = subject
			// lista de observables adicionales requeridos por el usuario, derivados del tema
			client._v_observables = []
		}

		// actualiza estado
		const setStatus = (status, error) => {
			if (client._v_ended) {
				return
			}
			client._v_status = status
			// todos los canales comparten un publicador de estado
			this._statusSubject.next({ name, status, error })
			_logger.info(name, status, error)
		}

		// canal conectado
		client.on('connect', packet => {
			setStatus('connect')
		})
		// canal desconectado
		client.on('disconnect', packet => {
			setStatus('disconnect')
		})
		// canal reconectando
		client.on('reconnect', () => {
			setStatus('reconnect')
		})
		// canal cerrado
		client.on('close', () => {
			setStatus('close')
		})
		// canal con error
		client.on('error', error => {
			setStatus('error', error.message)
		})
		// canal fuera de línea
		client.on('offline', error => {
			setStatus('offline')
		})

		// recepción de mensajes
		client.on('message', (topic, payload, packet) => {
			client._v_subject.next({
				topic,
				message: deserialize(payload),
				packet
			})
		})

		// guarda
		// TODO: expandir otros canales
		if (name === MASTER_CLIENT) {
			this._master = client
			// garantiza que en el canal principal, onConnection puede usar directamente la mayoría de los métodos
			// si es otro canal, debe usar messager.use para cambiar al canal real
			this._client = client
		}

		// inicializa plugins
		this._setup()

		// ejecuta callback después de crear conexión
		onConection && onConection(this)

		return client
	}

	// estadísticas de envío de mensajes
	_statistics(data) {
		// console.log('comenzando estadísticas..............')
		return data
	}

	/**
	 * Actualiza la conexión de un canal, no actualiza el messager
	 * @param {*} options
	 */
	update(options = {}) {
		// obtiene nuevos parámetros
		options = mergeDeepRight(this._client._v_options, options)
		// determina si se cambiaron parámetros clave [causará recreación de conexión]
		const keyPick = pick(['url', 'clientId'])
		const keyUpdated = !equals(keyPick(options), keyPick(this._client._v_options))
		// reemplaza options
		this._client._v_options = options

		// cambios que involucran reinicio de conexión
		if (keyUpdated) {
			// cierra canal en modo preservación, preparando para recrear canal
			this.end(false)
			// recrea client
			this._createClientAndWatch(this.name, options, this._client)
		}

		// notifica a plugins actualización de parámetros
		Object.values(VoerkaMessager.updates).forEach(update => {
			update && update.call(this, options)
		})
	}

	// obtiene parámetros del cliente
	_getClientOptions(name) {
		const { base, master, clients } = this._options
		let options
		if (!name || name === MASTER_CLIENT) {
			options = mergeDeepRight(base, master)
		} else {
			options = mergeDeepRight(base, clients[name] || {})
		}
		return options
	}

	/**
	 * Crea conexión
	 * Crea todas las conexiones aquí, conexiones de respaldo, conexiones de extensión
	 * Nota: si hay conexión automática entonces necesariamente no se pueden usar los parámetros en tempMessager
	 */
	connect() {
		this._assertMaster()
		// TODO: por ahora solo se hace la conexión del cliente principal, temporalmente no se manejan otros clients
		this._createClientAndWatch(MASTER_CLIENT, this._getClientOptions(MASTER_CLIENT))
	}

	// termina la conexión del cliente actual
	end(clean = true, ...params) {
		this._assertClient()
		// en modo limpio, cierra completamente los subjects del canal
		// en modo preservación, es decir cuando posiblemente un nuevo client reemplazará al anterior, para evitar que las suscripciones de observación anteriores dejen de funcionar, necesita continuar usando los subjects anteriores, solo el cliente mqtt es reemplazado
		if (clean) {
			// termina subjects relacionados con mensajes del canal
			this._client._v_subject?.complete()
			this._client._v_out_subject?.complete()
		}
		// termina cliente mqtt
		const res = this._client.end(...params)
		// guarda parámetros del cliente actual, se usarán después si se permite reiniciar una conexión después de end
		this._clientOptions[this.name] = this._client._v_options
		// marca cliente como cerrado activamente
		this._client._v_ended = true
		return res
	}

	// escucha mensajes del cliente actual
	on(...params) {
		this._assertClient()
		return this._client.on(...params)
	}

	// publica mensaje
	publish() {
		this._assertClient()
		// mqtt.Client#publish() estándar
		let data = Args(
			[
				{ topic: Args.STRING | Args.Required },
				{ message: Args.OBJECT | Args.Required },
				{ options: Args.OBJECT | Args.Optional },
				{ callback: Args.FUNCTION | Args.Optional }
			],
			arguments
		)
		const { topic, message, options = {} } = data
		const { straight = false } = options
		// directo, indica que el mensaje entra directamente a recepción
		if (straight) {
			this._client._v_subject.next({
				topic,
				message: message,
				packet: null
			})
		}

		// envía
		// arroja al subject
		data = pipeWhileNotNil(this._interceptors)(data)
		this._client._v_out_subject.next(data)

		return { topic, message }
	}

	// recibe mensaje
	onMessage(observer) {
		this._assertClient()
		if (typeof observer === 'function') {
			observer = {
				next: observer
			}
		}
		// devuelve objeto de suscripción, para cancelar suscripción xx.unsubscribe()
		return this._client._v_subject.subscribe(observer)
	}

	// suscribe a cambios de estado del cliente actual
	onStatus(observer) {
		this._assertClient()
		if (typeof observer === 'function') {
			observer = {
				next: observer
			}
		}
		// devuelve objeto de suscripción, para cancelar suscripción xx.unsubscribe()
		return this._statusSubject.subscribe(observer)
	}

	// crea observable personalizado
	getObservable(operators = []) {
		this._assertClient()
		if (operators && operators.length) {
			const observable = this._client._v_subject.pipe(...operators)
			// guarda, aunque no sirve de mucho
			this._client._v_observables.push(observable)
			return observable
		}
	}

	// crea un "observable que solo observa mensajes bajo cierto tema"
	// facilita que usuarios se suscriban rápidamente a mensajes bajo ciertos temas
	getTopicObservable(tp = '') {
		if (!tp) {
			return
		}
		let filterFunc
		// cadena
		if (typeof tp === 'string') {
			filterFunc = ({ topic }) => topic.endsWith(tp)
		} else if (tp instanceof RegExp) {
			// expresión regular
			filterFunc = ({ topic }) => tp.test(topic)
		} else if (typeof tp === 'function') {
			// método
			filterFunc = ({ topic }) => tp(topic)
		}
		return this.getObservable([filter(filterFunc)])
	}

	// obtiene observable de mensajes
	getMessageObservable(func = () => true) {
		const filterFunc = ({ message }) => func(message)
		return this.getObservable([filter(filterFunc)])
	}

	// suscribe a tema
	subscribe(...params) {
		this._assertClient()
		return this._client.subscribe(...params)
	}

	// cancela suscripción a tema
	unsubscribe(...params) {
		this._assertClient()
		return this._client.unsubscribe(...params)
	}

	// reconecta
	reconnect(...params) {
		this._assertClient()
		return this._client.reconnect(...params)
	}

	/**
	 * Intercepta antes de publicar mensaje
	 * 1. Temporalmente usa array simple para implementar, no se puede cancelar
	 * 2. Solo intercepta antes de enviar, no después de recibir, porque eso sería igual que la implementación de recepción
	 * 3. Para simplificar, todos los clientes usan un interceptor, juzgar origen de interceptación internamente
	 * @param {*} interceptor
	 * @deprecated Obsoleto, elegir defineOutSubject para implementar
	 */
	useInterceptors(interceptor) {
		_logger.warn('"useInterceptors" has deprecated at ^2.4.6 !!! Plase use "defineOutSubject" instead.')
		if (typeof interceptor === 'function') {
			this._interceptors.unshift(interceptor)
		}
	}
}

// define método reemplazable
VoerkaMessager.prototype._createMessageInSubject._replaceable = true
// implementa mecanismo de plugins
VoerkaMessager.setups = {}
VoerkaMessager.updates = {}
VoerkaMessager.use = function (plugin = {}) {
	const { name, setup, update, ...otherFuncs } = plugin
	if (!name || VoerkaMessager.setups[name]) {
		// sin nombre o ya registrado, retorna directamente
		return
	}
	// agrega método de inicialización al pool
	VoerkaMessager.setups[name] = setup
	// agrega método de actualización al pool
	VoerkaMessager.updates[name] = update
	// mezcla
	Object.keys(otherFuncs).forEach(key => {
		if (!VoerkaMessager.prototype.hasOwnProperty(key) || VoerkaMessager.prototype[key]._replaceable) {
			VoerkaMessager.prototype[key] = otherFuncs[key]
		}
	})
}

// preestablece plugin de negocio voerka
VoerkaMessager.use(VoerkaPlugin)
