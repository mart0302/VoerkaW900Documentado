/*
 * @Date: 2021/05/17 14:20:48
 * @Author: cong99
 * @Description: implementación del negocio voerka, integrado como plugin
 * @TODO: actualmente no se considera el problema de múltiples canales
 */
import {
	defineMessage,
	getMessageId,
	MESSAGE_TYPE,
	RESPONSE_CODE,
	EVENT_CODE,
	TOPICS,
	TRANSACTION_RESULT
} from './message'
import { mergeDeepRight, equals, mergeWith } from 'ramda'
import { Subject } from 'rxjs'
import { filter, share, map } from 'rxjs/operators'
import _logger from '../logger'
import FlakeId from 'flakeid'

// solo hace merge si hay valor
const mergeWithValue = mergeWith((l, r) => r || l)

// elimina caracteres especificados al inicio y/o final
function trim(str = '', char, type) {
	if (char) {
		if (type == 'left') {
			return str.replace(new RegExp('^\\' + char + '+', 'g'), '')
		} else if (type == 'right') {
			return str.replace(new RegExp('\\' + char + '+$', 'g'), '')
		}
		return str.replace(new RegExp('^\\' + char + '+|\\' + char + '+$', 'g'), '')
	}
	return str.replace(/^\s+|\s+$/g, '')
}

// método de inicialización del plugin
function setup() {
	// solo inicializa el canal principal, actualmente este plugin solo soporta el canal principal
	if (!this.voerka) {
		this._sid = 1
		const { voerka = {} } = this._options.master
		this.voerka = this._getOptions(voerka)
	}
	// observa mensajes de respuesta
	// si un subject derivado se completa, todos los subjects se completan
	// aquí se puede reemplazar directamente porque todas las suscripciones serán terminadas, de lo contrario hay que tener cuidado con las fugas de memoria
	// más adelante revisaremos rxjs

	// el tema de respuesta tiene una especificación estricta, no soporta transacciones, no soporta grupos, solo soporta temas de dispositivo propio
	// P.S. de lo contrario sería caótico, porque no podemos garantizar qué temas suscribirá la aplicación, incluso si queremos limitarlo, al final se basa en to, lo que también es un tema de dispositivo propio, al final es lo mismo
	this.answerObservable = this.getTopicObservable(TOPICS.ANSWER.toVoerkaTopic(this.voerka))
	// suscribe por defecto al tema de mensajes del dispositivo, no se cuenta en subscriptions
	const deviceTopic = TOPICS.DEVICE.toVoerkaTopic(this.voerka)
	this.subscribe(deviceTopic)
	// suscribe a las suscripciones inicializadas por el usuario
	this.voerka.subscriptions.forEach(topic => {
		topic = topic.toVoerkaTopic(this.voerka)
		// suscribe si el tema no es el tema de mensajes del dispositivo
		if (topic !== deviceTopic) {
			this.subscribe(topic)
		}
	})
	// generador de tid
	this._tidGenerator = new FlakeId(this.voerka.flake)

	// imprime suscripciones actuales
	_logger.info('subscriptions', this.subscriptions)
}

export default {
	// nombre del plugin
	name: 'voerka',

	setup,

	_getOptions(options = {}) {
		return mergeDeepRight(
			{
				/** información básica, puede usarse para instanciar temas (toVoerkaTopic) */
				sn: 'voerka_demo1',
				domain: 'hispro',
				group: '',

				/** configuración de parámetros */
				sessionTimeout: 30 * 1000,
				bufferMax: 100,
				flake: {}, // algoritmo de copo de nieve para generar tid, ver detalles en https://www.npmjs.com/package/flakeid
				subscriptions: [] // suscripciones iniciales del usuario, las suscripciones iniciales pueden ser resuscritas, pero las suscripciones dinámicas durante la ejecución se perderán, este problema no se resolverá por ahora
			},
			options
		)
	},

	// actualización de parámetros
	update(options) {
		// asegura canal principal
		this._assertMaster()
		// si cambia domain o sn, resuscribe todo
		let { voerka = {} } = options
		voerka = this._getOptions(voerka)
		const focus = ['sn', 'domain', 'subscriptions']
		const resubscribe = focus.some(key => !equals(voerka[key], this.voerka[key]))
		// después de comparar, asigna directamente para actualizar
		this.voerka = voerka
		if (resubscribe) {
			_logger.info('subscriptions', this.subscriptions)
			_logger.warn(`key option: [${focus}] updated, Resubscribe!!!`)
			// cancela todas las suscripciones
			this.subscriptions.forEach(topic => {
				this.unsubscribe(topic)
			})
			// resuscribe
			setup.call(this)
		}
	},

	// crea subject raíz para recepción de mensajes
	_createMessageInSubject() {
		// id de mensaje (no usa array o diccionario por separado, puede aprovechar las ventajas de ambos, implementa búsqueda n1, eliminación n1)
		this._messageBuffer = {}
		this._messageIdList = []

		// inserta en buffer de deduplicación
		const pushInBuffer = id => {
			// si excede la capacidad máxima del buffer, elimina el más antiguo
			if (this._messageIdList.length >= this.voerka.bufferMax) {
				delete this._messageBuffer[this._messageIdList.shift()]
			}
			// inserta el nuevo
			this._messageIdList.push(id)
			this._messageBuffer[id] = true
		}

		// crea subject
		// aquí el filtrado debe implementarse manteniendo algunos datos
		return new Subject().pipe(
			map(item => {
				item.message.id = getMessageId(item.message)
				return item
			}),
			filter(item => {
				const { id } = item.message
				if (id in this._messageBuffer) {
					return false
				} else {
					pushInBuffer(id)
					return true
				}
			}),
			// comparte, para evitar que la deduplicación previa se ejecute múltiples veces
			share()
		)
	},

	// definición de mensaje predeterminado, relleno basado en información de instancia
	defineMessage(message = {}, options = {}) {
		return defineMessage(
			mergeDeepRight(
				{
					from: this.voerka.sn
				},
				message
			),
			options
		)
	},

	// envía mensaje
	// soporta sesiones, las sesiones son un concepto creado por voerka, por lo que se escribe aquí y no en index
	publishMessage(topic, message = {}, options = {}) {
		// asegura canal principal
		this._assertMaster()
		// obtiene parámetros (solo obtiene los relacionados con voerka, hay otros parámetros que son de messager)
		const { timeout = this.voerka.sessionTimeout } = options
		// si sid es true, indica que messager debe crear el sid
		if (message.sid === true) {
			message.sid = this._sid++
		}
		// si tid de transacción es true, indica que messager debe crear el tid
		if (message.tid === true) {
			message.tid = this.genTid()
		}
		// procesa topic
		topic = this.getTopic(topic, message)

		if (isNaN(message.sid) || Number(message.sid) === 0) {
			// envía directamente
			return this.publish(topic, message, options)
		} else {
			// sesión, espera respuesta, luego
			// verificación de sesión: si sid es igual, en esta etapa no verifica si from=to anterior
			return new Promise((r, j) => {
				let getAnswer = false
				let pid
				// respuesta dentro del tiempo especificado
				const subscription = this.answerObservable.subscribe(data => {
					const answer = data.message || {}
					// para prevenir que algunos dispositivos no sigan las reglas, se compara usando String
					if (String(answer.sid) === String(message.sid) && !getAnswer) {
						getAnswer = true
						subscription.unsubscribe()
						pid && clearTimeout(pid)
						// devuelve resultado
						r(answer)
					}
				})

				// tiempo de espera
				pid = setTimeout(() => {
					// si no se obtiene resultado, lanza error
					subscription && subscription.unsubscribe()
					if (!getAnswer) {
						getAnswer = true
						j(new Error('Timeout'))
					}
				}, timeout)

				// envía la solicitud real
				this.publish(topic, message, options)
			})
		}
	},

	// envía solicitud de registro [yo envío solicitud de registro]
	postRegister(message = {}) {},

	// envía notificación [yo envío notificación]
	postNotify(message = {}) {},

	// envía alarma [yo envío alarma]
	postAlarm(message = {}, payload = {}, options = {}) {
		const topic = message.group
			? TOPICS.ALARMS_GROUP // tipo grupo, alarma
			: TOPICS.ALARMS // tipo dispositivo, alarma
		return this.publishMessage(
			topic,
			this.defineMessage({
				...message,
				type: MESSAGE_TYPE.ALARMS,
				payload
			}),
			options
		)
	},

	// envía evento [yo envío evento]
	postEvent(message = {}, payload = {}, options = {}) {
		const topic = message.group
			? TOPICS.EVENTS_GROUP // tipo grupo, evento
			: TOPICS.EVENTS // tipo dispositivo, evento
		return this.publishMessage(
			topic,
			this.defineMessage({
				...message,
				type: MESSAGE_TYPE.EVENTS,
				payload
			}),
			options
		)
	},

	// envía mensaje [yo envío mensaje]
	postMessage(message = {}) {},

	// envía datos [yo envío datos]
	postData(message = {}) {},

	// envía consulta [yo envío consulta]
	postQuery(message = {}) {},

	// envía difusión [yo envío difusión]
	postBroadcast(message = {}) {},

	// envía respuesta [yo envío respuesta]
	postAnswer(message = {}, payload = {}, options = {}) {
		return this.publishMessage(
			TOPICS.ANSWER,
			this.defineMessage({
				...message,
				type: MESSAGE_TYPE.ANSWER,
				payload
			}),
			options
		)
	},

	// envía acción [yo envío acción]
	postAction(message = {}, payload = {}, options = {}) {
		return this.publishMessage(
			TOPICS.ACTIONS,
			this.defineMessage({
				...message,
				type: MESSAGE_TYPE.ACTIONS,
				payload
			}),
			options
		)
	},

	// envía atributos [yo envío atributos]
	postAttrs(message = {}, payload = {}, options) {
		return this.publishMessage(
			TOPICS.ATTRS,
			this.defineMessage({
				...message,
				type: MESSAGE_TYPE.ATTRS,
				payload
			}),
			options
		)
	},

	// envía evento de recurso [yo envío evento de recurso]
	postResEvent(code, info = {}, res = {}, message = {}, options) {
		return this.postEvent(
			message,
			{
				code,
				info,
				res
			},
			options
		)
	},

	// envía evento de recurso creado [yo envío evento de recurso creado]
	postResCreated(...params) {
		return this.postResEvent(EVENT_CODE.RESOURCE_CREATED, ...params)
	},

	// envía evento de recurso actualizado [yo envío evento de recurso actualizado]
	postResUpdated(...params) {
		return this.postResEvent(EVENT_CODE.RESOURCE_UPDATED, ...params)
	},

	// envía evento de recurso eliminado [yo envío evento de recurso eliminado]
	postResDeleted(...params) {
		return this.postResEvent(EVENT_CODE.RESOURCE_DELETED, ...params)
	},

	// actualiza dispositivo [yo actualizo dispositivo]
	upgradeDevice(target, data = {}) {
		return this.postAction({ to: target }, { action: 'upgrade', ...data })
	},

	// establece atributos de dispositivo [yo establezco atributos de dispositivo]
	setDeviceAttrs(target, data = {}) {
		return this.postAttrs({ to: target }, data)
	},

	// establece progreso de transacción [yo establezco progreso de transacción]
	setTransactionProgress(message, { progress = 10, result = TRANSACTION_RESULT.HANDLING, ...data } = {}, options) {
		return this.postEvent(
			message,
			{
				code: EVENT_CODE.DEVICE_TRANS_PROGRESS,
				progress,
				result,
				...data
			},
			options
		)
	},

	// maneja alarma [yo manejo alarma]
	handleAlarm(message, { remarks = '', result = TRANSACTION_RESULT.NOT_SERVICED, ...data } = {}, options) {
		return this.postEvent(
			message,
			{
				code: EVENT_CODE.DEVICE_ALARM_HANDLED,
				remarks,
				result,
				...data
			},
			options
		)
	},

	// genera tid [yo genero tid]
	genTid() {
		return this._tidGenerator.gen()
	},

	// obtiene tema [yo obtengo tema]
	getTopic(topic, message = {}) {
		return typeof topic === 'string' ? topic.toVoerkaTopic(message) : topic.toVoerkaTopic(message)
	}
}
