/*
 * @Date: 2021/05/17 14:20:48
 * @Author: cong99
 * @Description: voerka业务实现，以插件形式集成
 * @TODO: 当前未考虑多信道问题
 */
import {
	defineMessage,
	getMessageId,
	MESSAGE_TYPE,
	RESPONSE_CODE,
	EVENT_CODE,
	TOPICS,
	TRANSACTION_RESULT
} from './message'
import { mergeDeepRight, equals, mergeWith } from 'ramda'
import { Subject } from 'rxjs'
import { filter, share, map } from 'rxjs/operators'
import _logger from '../logger'
import FlakeId from 'flakeid'

// 有值才merge
const mergeWithValue = mergeWith((l, r) => r || l)

// 去除前后指定字符串
function trim(str = '', char, type) {
	if (char) {
		if (type == 'left') {
			return str.replace(new RegExp('^\\' + char + '+', 'g'), '')
		} else if (type == 'right') {
			return str.replace(new RegExp('\\' + char + '+$', 'g'), '')
		}
		return str.replace(new RegExp('^\\' + char + '+|\\' + char + '+$', 'g'), '')
	}
	return str.replace(/^\s+|\s+$/g, '')
}

// 插件初始化方法
function setup() {
	// 仅初始主信道，目前此插件仅支持主信道
	if (!this.voerka) {
		this._sid = 1
		const { voerka = {} } = this._options.master
		this.voerka = this._getOptions(voerka)
	}
	// 观察应答消息
	// 衍生的subject如果complete，则所有subject都被complete
	// 此处可以直接替换，因为这里的所有订阅都会被结束掉，否则的话要小心内存泄漏
	// 后面有空再看看rxjs

	// 应答主题严格规范，不支持事务、不支持group，只支持自身设备主题
	// P.S. 否则会混乱，因为不敢保证应用会订阅什么样的主题，即便是要限制，最终还是根据to，那样不也是自身设备主题，最终还是一样
	this.answerObservable = this.getTopicObservable(TOPICS.ANSWER.toVoerkaTopic(this.voerka))
	// 默认订阅设备消息主题，不计入subscriptions
	const deviceTopic = TOPICS.DEVICE.toVoerkaTopic(this.voerka)
	this.subscribe(deviceTopic)
	// 订阅用户初始化订阅
	this.voerka.subscriptions.forEach(topic => {
		topic = topic.toVoerkaTopic(this.voerka)
		// 主题不是设备消息主题则订阅
		if (topic !== deviceTopic) {
			this.subscribe(topic)
		}
	})
	// tid生成器
	this._tidGenerator = new FlakeId(this.voerka.flake)

	// 打印当前订阅
	_logger.info('subscriptions', this.subscriptions)
}

export default {
	// 插件名称
	name: 'voerka',

	setup,

	_getOptions(options = {}) {
		return mergeDeepRight(
			{
				/** 基本信息，可用于实例化主题(toVoerkaTopic) */
				sn: 'voerka_demo1',
				domain: 'hispro',
				group: '',

				/** 参数配置 */
				sessionTimeout: 30 * 1000,
				bufferMax: 100,
				flake: {}, // 雪花算法生成tid，详情请见https://www.npmjs.com/package/flakeid
				subscriptions: [] // 用户的初始化订阅，初始话订阅可以被重新订阅，但是如果是运行中的动态订阅，就会被损失，此问题暂不解决
			},
			options
		)
	},

	// 参数更新
	update(options) {
		// 断言主信道
		this._assertMaster()
		// 如果改变domain或者sn，重新订阅所有
		let { voerka = {} } = options
		voerka = this._getOptions(voerka)
		const focus = ['sn', 'domain', 'subscriptions']
		const resubscribe = focus.some(key => !equals(voerka[key], this.voerka[key]))
		// 比较完毕直接赋值更新
		this.voerka = voerka
		if (resubscribe) {
			_logger.info('subscriptions', this.subscriptions)
			_logger.warn(`key option: [${focus}] updated, Resubscribe!!!`)
			// 取消所有订阅
			this.subscriptions.forEach(topic => {
				this.unsubscribe(topic)
			})
			// 重新订阅
			setup.call(this)
		}
	},

	// 创建消息接收根subject
	_createMessageInSubject() {
		// 消息id（不单独适用数组或者字典，可以兼顾两者的有点，实现n1查询，n1删除）
		this._messageBuffer = {}
		this._messageIdList = []

		// 塞进去重buffer
		const pushInBuffer = id => {
			// 超过buffer最大容量，剔除最旧的
			if (this._messageIdList.length >= this.voerka.bufferMax) {
				delete this._messageBuffer[this._messageIdList.shift()]
			}
			// 塞进新的
			this._messageIdList.push(id)
			this._messageBuffer[id] = true
		}

		// 创建subject
		// 此处过滤必须通过自己维护一些数据来实现
		return new Subject().pipe(
			map(item => {
				item.message.id = getMessageId(item.message)
				return item
			}),
			filter(item => {
				const { id } = item.message
				if (id in this._messageBuffer) {
					return false
				} else {
					pushInBuffer(id)
					return true
				}
			}),
			// 分享，以免前置的去重多次被执行
			share()
		)
	},

	// 预设消息定义，基于实例的信息的填充
	defineMessage(message = {}, options = {}) {
		return defineMessage(
			mergeDeepRight(
				{
					from: this.voerka.sn
				},
				message
			),
			options
		)
	},

	// 发送消息
	// 支持会话，会话是voerka创造的概念，所以写在这里，而不写在index里
	publishMessage(topic, message = {}, options = {}) {
		// 断言主信道
		this._assertMaster()
		// 获取参数(只获取voerka相关，还有些参数时messager的)
		const { timeout = this.voerka.sessionTimeout } = options
		// 如果sid为true，表示交给messager创建sid
		if (message.sid === true) {
			message.sid = this._sid++
		}
		// 事务tid为true，表示交给messager创建tid
		if (message.tid === true) {
			message.tid = this.genTid()
		}
		// 处理topic
		topic = this.getTopic(topic, message)

		if (isNaN(message.sid) || Number(message.sid) === 0) {
			// 直接发送
			return this.publish(topic, message, options)
		} else {
			// 会话，等待返回，然后
			// 会话判断：是否sid相同，现阶段不判断是否from=之前发送的to
			return new Promise((r, j) => {
				let getAnswer = false
				let pid
				// 规定时间内返回
				const subscription = this.answerObservable.subscribe(data => {
					const answer = data.message || {}
					// 防止有些设备不按规矩来，所以统一用String进行比较
					if (String(answer.sid) === String(message.sid) && !getAnswer) {
						getAnswer = true
						subscription.unsubscribe()
						pid && clearTimeout(pid)
						// 返回结果
						r(answer)
					}
				})

				// 超时
				pid = setTimeout(() => {
					// 如果未获取结果则抛错
					subscription && subscription.unsubscribe()
					if (!getAnswer) {
						getAnswer = true
						j(new Error('Timeout'))
					}
				}, timeout)

				// 实际发出请求
				this.publish(topic, message, options)
			})
		}
	},

	// 发起登记请求【我发送登记请求】
	postRegister(message = {}) {},

	// 发送通知【我发送通知】
	postNotify(message = {}) {},

	// 发送告警【我发送告警】
	postAlarm(message = {}, payload = {}, options = {}) {
		const topic = message.group
			? TOPICS.ALARMS_GROUP // 分组类型，告警
			: TOPICS.ALARMS // 设备类型，告警
		return this.publishMessage(
			topic,
			this.defineMessage({
				...message,
				type: MESSAGE_TYPE.ALARMS,
				payload
			}),
			options
		)
	},

	// 发送事件【我发送事件】
	postEvent(message = {}, payload = {}, options = {}) {
		const topic =
			payload.code === EVENT_CODE.DEVICE_STATUS_CHANGED
				? message.group
					? TOPICS.EVENTS_STATUS_GROUP // 分组类型，状态变更事件
					: TOPICS.EVENTS_STATUS // 设备类型，状态变更事件
				: message.group
				? TOPICS.EVENTS_GROUP // 分组类型，事件
				: TOPICS.EVENTS // 设备类型，事件

		return this.publishMessage(
			topic,
			this.defineMessage({
				...message,
				type: MESSAGE_TYPE.EVENTS,
				payload
			}),
			options
		)
	},

	// 发送消息【我发送消息】
	postMessage(message = {}) {},

	// 发送数据【我发送数据】
	postData(message = {}) {},

	// 发送查询【我发送查询】
	postQuery(message = {}) {},

	// 发送广播【我发送广播】
	postBroadcast(message = {}) {},

	// 发送应答消息【我发送应答消息，整个应答的回程，单程票】
	// 记得message中要带sid，否则无意义
	postAnswer(message = {}, payload = {}, options = {}) {
		// 此处必然有sid，否则没有意义，但又是单程的，所以使用更底层的publish而不是publishMessage
		return this.publish(
			this.getTopic(TOPICS.ANSWER, message), // topic就必须自己组装
			this.defineMessage({
				...message,
				type: MESSAGE_TYPE.ANSWER,
				payload
			}),
			options
		)
	},

	// 执行动作【我命令你执行动作】
	postAction(message = {}, payload = {}, options = {}) {
		return this.publishMessage(
			TOPICS.ACTIONS,
			this.defineMessage({
				...message,
				type: MESSAGE_TYPE.ACTIONS,
				payload
			}),
			options
		)
	},

	// 设置属性【我命令你修改属性】
	postAttrs(message = {}, payload = {}, options) {
		return this.publishMessage(
			TOPICS.ATTRS,
			this.defineMessage({
				...message,
				type: MESSAGE_TYPE.ATTRS,
				payload
			}),
			options
		)
	},

	/** 资源变更事件 */
	postResEvent(code, info = {}, res = {}, message = {}, options) {
		const { type, sub_type, sub_id } = info
		const topic = sub_type && sub_id ? TOPICS.RESOURCE_SUB : TOPICS.RESOURCE
		return this.publishMessage(
			topic.toVoerkaTopic(info),
			this.defineMessage({
				...message,
				type: MESSAGE_TYPE.EVENTS,
				payload: {
					code,
					resType: sub_type || type,
					res
				}
			}),
			options
		)
	},

	// 资源创建
	postResCreated(...params) {
		return this.postResEvent(EVENT_CODE.RESOURCE_CREATED, ...params)
	},

	// 资源更新
	postResUpdated(...params) {
		return this.postResEvent(EVENT_CODE.RESOURCE_UPDATED, ...params)
	},

	// 资源删除
	postResDeleted(...params) {
		return this.postResEvent(EVENT_CODE.RESOURCE_DELETED, ...params)
	},

	/** 快捷方法 */
	// 升级设备
	upgradeDevice(target, data = {}) {
		return this.postAction({ to: target, sid: true }, { action: 'upgrade', ...data })
	},

	// 设置设备属性
	setDeviceAttrs(target, data = {}) {
		return this.postAttrs({ to: target, sid: true }, data)
	},

	// 事务进度事件
	setTransactionProgress(message, { progress = 10, result = TRANSACTION_RESULT.HANDLING, ...data } = {}, options) {
		return this.postEvent(
			message,
			{
				...data,
				code: EVENT_CODE.DEVICE_TRANS_PROGRESS,
				progress,
				result
			},
			options
		)
	},

	// 处理告警
	// 告警取消结果有：11、15、19，分别对应“未服务（取消）”、“出错”、“超时” (单数)
	// 告警处理结果有：10、12、14、16，分别对应“完成”、“忽略”、“拒绝”、“误报” (双数)
	handleAlarm(message, { remarks = '', result = TRANSACTION_RESULT.NOT_SERVICED, ...data } = {}, options) {
		// 修正result
		result = result >= TRANSACTION_RESULT.COMPLETED ? result : TRANSACTION_RESULT.COMPLETED
		// 判断是告警取消还是告警已处理
		const code = Number(result) % 2 === 1 ? EVENT_CODE.DEVICE_ALARM_CANCELLED : EVENT_CODE.DEVICE_ALARM_HANDLED

		return this.postEvent(
			message,
			{
				...data,
				code,
				remarks,
				result
			},
			options
		)
	},

	// 生成tid
	genTid() {
		// 大数，应该使用BigInt，但是此处不作修改了，字符串也行
		return this._tidGenerator.gen().toString()
	},

	// 获取主题
	getTopic(topic, message = {}) {
		// 如果有to，说明主题是要发给某设备的，说明to才是主题的sn，否则就是发给自己
		const { to, domain, group, tid } = message
		return topic.toVoerkaTopic(mergeWithValue(this.voerka, { sn: to, domain, group: trim(group, '/'), tid }))
	}
}
