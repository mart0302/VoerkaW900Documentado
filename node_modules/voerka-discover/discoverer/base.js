const { isClass } = require("../utils/typecheck");
const { flexibleRequire } = require('../utils/requireutils');

const { CommandMessage: { getMessageByCmdType } } = require('../lib/voerkaTransfer/protocols/vimp/message');

class DiscoverBase {
    constructor({ settings = {}, msgHandler, transferClass, sessionManager } = {}) {
        if (typeof msgHandler !== 'function') throw new Error('Message handler is not a function');
        transferClass = transferClass || flexibleRequire(settings.transfer);
        if (!isClass(transferClass)) throw new Error(`Transfer class ${transferClass} is an invalid class`);

        this.settings = settings;
        this.msgHandler = msgHandler;
        this.transferClass = transferClass;
        this.sessionManager = sessionManager;

        this._start = this.start;
        this.start = (async function (...args) {
            if (this.settings.timeout) setTimeout(() => { this.stop(); }, this.settings.timeout);
            await this._start(...args);
        }).bind(this);
    }
    async load() {
        await this.loadTransfer();
    }
    async unload() {
        await this.unloadTransfer();
    }
    async loadTransfer() {
        this.transfer = new this.transferClass(this.settings, this.sessionManager);
        this.transfer.on('data', async ({ err, data, context }) => {
            if (this.filter({ data, context })) {
                ({ err, data = data, context = context } = await this.convert({ data, context }) || {});
                if (err) logger.error(`Error converting data: ${err.stack}`);
                else this.msgHandler({ data, context });
            }
        });
        await this.transfer.init();
        await this.transfer.connect();
    }
    async unloadTransfer() {
        await this.stop();
        await this.transfer.disconnect();
    }
    async init() {}
    async start(options = {}) {}
    async stop(options = {}) {}
    async filter({ data, context }) { return true; }
    async convert({ data, context }) {}
    async config({ sn, cmd, sid, payload }, options = {}) {}
}

class VIMPDiscoverBase extends DiscoverBase {
    constructor(...args) {
        super(...args);
        this._config = this.config;
        this.config = (async function(...args) {
            let { err, result: [_, options], message } = Object.assign({ result: args }, this.beforeConfig(...args));
            return err ? { err, message } : { ...await this._config(message, options), message };
        }).bind(this);
    }
    beforeConfig({ sn, cmd, sid, payload }, { message }) {
        let data = { SN: sn, Cmd: cmd, Sid: sid, Payload: payload };
        if (!message) {
            this.formatPayload(payload);
            let Message = getMessageByCmdType(cmd);
            if (!Message) return { err: new Error('Config cmd not available'), result: arguments };
            // VerificaciÃ³n
            let invalidateMessage = Message.validate(data);
            if (invalidateMessage) return { err: new Error(invalidateMessage), result: arguments };
            message = new Message(data);
        }
        return { result: arguments, message };
    }
    formatPayload(payload) {
        for (let key in payload) {
            switch (key) {
                case 'Networks':
                    payload[key].map(network => {
                        delete network.MAC;
                        for (let item in network) {
                            switch (item) {
                                case 'IP':
                                case 'SubnetMask':
                                case 'Gateway':
                                case 'DNS_prefer':
                                case 'DNS_alter':
                                    typeof network[item] === 'string'
                                        && (network[item] = network[item].split('.').map(x => Number(x)));
                                    break;
                                case 'DHCP':
                                    network[item] = Number(network[item]);
                                    break;
                            }
                        }
                        return network;
                    });
                    break;
                case 'WIFI_Enable':
                    payload[key] = Number(payload[key]);
                    break;
                case 'Interface':
                case 'WIFI_Secret':
                case 'delay':
                    let number = Number(payload[key]);
                    if (!isNaN(number)) payload[key] = number;
                    break;
                case 'Domain':
                case 'MQTT':
                case 'MQTT_Username':
                case 'MQTT_Password':
                case 'WIFI_AP':
                case 'WIFI_Password':
                case 'Location':
                case 'url':
                    payload[key] += '';
                    break;
            }
        }
    }
}

module.exports = {
    DiscoverBase,
    VIMPDiscoverBase,
};
