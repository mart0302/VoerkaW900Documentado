const LocalDiscoverMulticastTransfer = require('../../lib/voerkaTransfer/transfers/vimpUdpTransfer');
const ms = require('ms');
const { VIMPDiscoverBase } = require('../base');
const { getIPRange } = require('get-ip-range');
const { parseIPInt } = require('utils/string');
const IPV4_REGEXP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;

const {
    InvitationMessage,
    DismissalMessage,
} = require('../../lib/voerkaTransfer/protocols/vimp/message');

const DISCOVER_INVITE_MULTICAST_ADDR = '239.8.8.8';
const DISCOVER_INVITE_MULTICAST_PORT = '2888';
const DISCOVER_INVITE_MULTICAST_INTERFACE = '';

const DISCOVER_UDP_PORT = '3888';
const DEVICE_UDP_PORT = '3888';

//Incluye escaneo de multidifusión y escaneo especificado
class LocalDiscoverer extends VIMPDiscoverBase {
    constructor({ settings = {}, msgHandler, transferClass }) {
        super({
            settings: {
                name: `voerka_local_discoverer_anonymous`,
                multicast: [{
                    addr: DISCOVER_INVITE_MULTICAST_ADDR,
                    port: DISCOVER_INVITE_MULTICAST_PORT,
                    interface: DISCOVER_INVITE_MULTICAST_INTERFACE
                }],
                udpPort: DISCOVER_UDP_PORT,
                deviceUdpPort: DEVICE_UDP_PORT,
                interval: '2s',
                transfer: 'services/discover/discoverer/local/transfer',
                ...settings
            },
            msgHandler,
            transferClass:  transferClass || LocalDiscoverMulticastTransfer
        });
        this.settings.interval = ms(this.settings.interval);
        let multicast = this.settings.multicast;
        if (!Array.isArray(multicast)) this.settings.multicast = [multicast];
        this.discoverByMode = {
            multicast: {
                start: this.startMulticastDiscover,
                stop: this.stopMulticastDiscover,
            },
            ipSpecified: {
                start: this.startIpSpecifiedDiscover,
                stop: this.stopIpSpecifiedDiscover,
            },
        };
    }

    async start({ mode = 'multicast', ip, networkInterface } = {}) {
        if (ip) mode = 'ipSpecified';
        if (networkInterface) this.networkInterface = networkInterface;
        let discover = this.discoverByMode[mode];
        if (!discover) throw new Error(`unsupported discover mode: ${mode}`);
        this.mode = mode;
        await discover.start.call(this, ...arguments);
    }
    async stop() {
        if (this.setTimeoutId) clearTimeout(this.setTimeoutId);
        this.networkInterface = null;
        let multicast = this.settings.multicast;
        let tasks = [];
        for (let i in multicast) {
            let task = this.transfer.send({
                data: new DismissalMessage({ SN: 'imdiscoverer' }),
                options: { address: `${multicast[i].addr}:${multicast[i].port}` }
            });
            tasks.push(task);
        }
        await Promise.all(tasks);  // Debes detenerte con éxito antes de poder tener éxito, de lo contrario puedes volver a intentarlo.
        await this.transfer.dropMembership(this.settings.multicast);
    }
    async config(data = {}, { by = 'udp', targetIP, timeout }) {
        if (by === 'udp') {
            return await this.transfer.session({ timeout }).send({
                data,
                options: { address: `${targetIP}:${this.transfer.deviceUdpPort}` }
            });
        }
        if (by === 'multicast') {
            let settings = this.settings;
            let multicast = settings.multicast;
            let tasks = [];
            for (let i in multicast) {
                let task = this.transfer.session({ timeout }).send({
                    data,
                    options: { address: `${multicast[i].addr}:${settings.deviceUdpPort}` }
                });
                tasks.push(task);
            }
            return await Promise.race(tasks);  // Siempre que un transmisor envíe con éxito
        }
    }

    // Escaneo de multidifusión ///////////////////////////////////////////////////////////////////////////////
    async startMulticastDiscover() {
        let settings = this.settings;
        let multicast = settings.multicast;
        let tasks = [];
        for (let i in multicast) {
            let options = this.networkInterface ?
                { ...multicast[i], interface: this.networkInterface }
                :
                multicast[i];
            await this.transfer.addMembership(options);
            if (settings.interval) {
                let interval = this.settings.interval;
                let sendInvitation = () => {
                    this.sendInvitationByMulticast();
                    this.setTimeoutId = setTimeout(sendInvitation, interval)
                };
                sendInvitation();
            } else {
                this.sendInvitationByMulticast();
            }
        }
    }
    async sendInvitationByMulticast() {
        let settings = this.settings;
        let multicast = settings.multicast;
        let tasks = [];
        for (let i in multicast) {
            let task = this.transfer.send({
                data: new InvitationMessage({ SN: 'imdiscoverer' }),
                options: { address: `${multicast[i].addr}:${settings.deviceUdpPort/*multicast[i].port*/}` }
            });
            tasks.push(task);
        }
        await Promise.race(tasks);  // Compite para enviar invitaciones. Si uno de ellos tiene éxito, ganará.
    }
    async stopMulticastDiscover() {
        let multicast = this.settings.multicast;
        let tasks = [];
        for (let i in multicast) {
            let task = this.transfer.send({
                data: new DismissalMessage({ SN: 'imdiscoverer' }),
                options: { address: `${multicast[i].addr}:${multicast[i].port}` }
            });
            tasks.push(task);
        }
        await Promise.all(tasks);  // Debes detenerte con éxito antes de poder tener éxito, de lo contrario puedes volver a intentarlo.
        await this.transfer.dropMembership(this.settings.multicast);
    }
    // Escaneo de multidifusión ///////////////////////////////////////////////////////////////////////////////

    //Escaneo de IP /// ...
    async startIpSpecifiedDiscover({ ip } = {}) {
        // Tres formas de entrada IP:
        // 1. Cadena: "x.x.x.x": una IP específica
        // 2. Cadena: "x.x.x.x, y.y.y.y": un rango de IP determinado
        // 3. Matriz: [/*las dos primeras cadenas*/]
        if (Array.isArray(ip)) {
            for (let _ip of ip) await this.startIpSpecifiedDiscover(_ip);
        }
        else {
            let targetIPs;
            //Añade una coma al final. Si sólo se puede separar una IP, es una IP específica, de lo contrario es un rango de IP.
            let ipRange = `${ip},`.split(',').map(x => x.trim().replace('0.0.0.0', '')).filter(x => x);
            if (ipRange.length === 1) {
                if (IPV4_REGEXP.test(ipRange[0])) {
                    targetIPs = ipRange;
                }
                else {
                    throw new VError('invalid ip: {ip}', { ip });
                }
            }
            // Si el número de IP no es 2, es un rango de IP no válido
            else if (ipRange.length === 2) {
                // Y estas dos IP deberían ser IP legales
                let [startIp, endIp] = ipRange;
                // Y el número de IP en este rango de IP no debe exceder 1000
                if (IPV4_REGEXP.test(startIp) && IPV4_REGEXP.test(endIp)) {
                    if (parseIPInt(endIp) - parseIPInt(startIp) <= 1000) {
                        targetIPs = getIPRange(startIp, endIp);
                    }
                    else {
                        throw new VError('too large ip range: {ip}(more than 1000 IPs)', { ip });
                    }
                }
                else {
                    throw new VError('invalid ip range: {ip}', { ip });
                }
            }
            else {
                throw new VError('invalid ip range: {ip}', { ip });
            }

           // El intervalo de envío debe ser mayor que el número de direcciones IP * 5ms para evitar demasiados mensajes de red
            let interval = this.settings.interval && Math.min(targetIPs.length * 5, this.settings.interval);
            if (interval) {
                let sendInvitation = () => {
                    this.sendInvitationByIp(targetIPs);
                    this.setTimeoutId = setTimeout(sendInvitation, interval);
                };
                sendInvitation();
            } else {
                this.sendInvitationByIp(targetIPs);
            }
        }
    }
    async sendInvitationByIp(ip) {
        let settings = this.settings;
        ip = Array.isArray(ip) ? ip : [ip];
        for (let _ip of ip) {
            this.transfer.send({
                data: new InvitationMessage({ SN: 'imdiscoverer' }),
                options: { address: `${_ip}:${settings.deviceUdpPort}` }
            });
        }
    }
    async stopIpSpecifiedDiscover() {
        // no hacer nada
    }
    //Escaneo de IP /// ...
}

module.exports = LocalDiscoverer;
