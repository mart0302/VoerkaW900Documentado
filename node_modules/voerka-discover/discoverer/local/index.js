const LocalDiscoverMulticastTransfer = require('../../lib/voerkaTransfer/transfers/vimpUdpTransfer');
const ms = require('ms');
const { VIMPDiscoverBase } = require('../base');
const { getIPRange } = require('get-ip-range');
const { parseIPInt } = require('utils/string');
const IPV4_REGEXP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;

const {
    InvitationMessage,
    DismissalMessage,
} = require('../../lib/voerkaTransfer/protocols/vimp/message');

const DISCOVER_INVITE_MULTICAST_ADDR = '239.8.8.8';
const DISCOVER_INVITE_MULTICAST_PORT = '2888';
const DISCOVER_INVITE_MULTICAST_INTERFACE = '';

const DISCOVER_UDP_PORT = '3888';
const DEVICE_UDP_PORT = '3888';

// 包括组播扫描和指定扫描
class LocalDiscoverer extends VIMPDiscoverBase {
    constructor({ settings = {}, msgHandler, transferClass }) {
        super({
            settings: {
                name: `voerka_local_discoverer_anonymous`,
                multicast: [{
                    addr: DISCOVER_INVITE_MULTICAST_ADDR,
                    port: DISCOVER_INVITE_MULTICAST_PORT,
                    interface: DISCOVER_INVITE_MULTICAST_INTERFACE
                }],
                udpPort: DISCOVER_UDP_PORT,
                deviceUdpPort: DEVICE_UDP_PORT,
                interval: '2s',
                transfer: 'services/discover/discoverer/local/transfer',
                ...settings
            },
            msgHandler,
            transferClass:  transferClass || LocalDiscoverMulticastTransfer
        });
        this.settings.interval = ms(this.settings.interval);
        let multicast = this.settings.multicast;
        if (!Array.isArray(multicast)) this.settings.multicast = [multicast];
        this.discoverByMode = {
            multicast: {
                start: this.startMulticastDiscover,
                stop: this.stopMulticastDiscover,
            },
            ipSpecified: {
                start: this.startIpSpecifiedDiscover,
                stop: this.stopIpSpecifiedDiscover,
            },
        };
    }

    async start({ mode = 'multicast', ip, networkInterface } = {}) {
        if (ip) mode = 'ipSpecified';
        if (networkInterface) this.networkInterface = networkInterface;
        let discover = this.discoverByMode[mode];
        if (!discover) throw new Error(`unsupported discover mode: ${mode}`);
        this.mode = mode;
        await discover.start.call(this, ...arguments);
    }
    async stop() {
        if (this.setTimeoutId) clearTimeout(this.setTimeoutId);
        this.networkInterface = null;
        let multicast = this.settings.multicast;
        let tasks = [];
        for (let i in multicast) {
            let task = this.transfer.send({
                data: new DismissalMessage({ SN: 'imdiscoverer' }),
                options: { address: `${multicast[i].addr}:${multicast[i].port}` }
            });
            tasks.push(task);
        }
        await Promise.all(tasks);  // 都要停止成功才成，否则可重试
        await this.transfer.dropMembership(this.settings.multicast);
    }
    async config(data = {}, { by = 'udp', targetIP, timeout }) {
        if (by === 'udp') {
            return await this.transfer.session({ timeout }).send({
                data,
                options: { address: `${targetIP}:${this.transfer.deviceUdpPort}` }
            });
        }
        if (by === 'multicast') {
            let settings = this.settings;
            let multicast = settings.multicast;
            let tasks = [];
            for (let i in multicast) {
                let task = this.transfer.session({ timeout }).send({
                    data,
                    options: { address: `${multicast[i].addr}:${settings.deviceUdpPort}` }
                });
                tasks.push(task);
            }
            return await Promise.race(tasks);  // 只要有一个传输器发送成功即可
        }
    }

    // 组播扫描 ////////////////////////////////////////////////////////////
    async startMulticastDiscover() {
        let settings = this.settings;
        let multicast = settings.multicast;
        let tasks = [];
        for (let i in multicast) {
            let options = this.networkInterface ?
                { ...multicast[i], interface: this.networkInterface }
                :
                multicast[i];
            await this.transfer.addMembership(options);
            if (settings.interval) {
                let interval = this.settings.interval;
                let sendInvitation = () => {
                    this.sendInvitationByMulticast();
                    this.setTimeoutId = setTimeout(sendInvitation, interval)
                };
                sendInvitation();
            } else {
                this.sendInvitationByMulticast();
            }
        }
    }
    async sendInvitationByMulticast() {
        let settings = this.settings;
        let multicast = settings.multicast;
        let tasks = [];
        for (let i in multicast) {
            let task = this.transfer.send({
                data: new InvitationMessage({ SN: 'imdiscoverer' }),
                options: { address: `${multicast[i].addr}:${settings.deviceUdpPort/*multicast[i].port*/}` }
            });
            tasks.push(task);
        }
        await Promise.race(tasks);  // 竞争发送邀请，有一个发送成功则成
    }
    async stopMulticastDiscover() {
        let multicast = this.settings.multicast;
        let tasks = [];
        for (let i in multicast) {
            let task = this.transfer.send({
                data: new DismissalMessage({ SN: 'imdiscoverer' }),
                options: { address: `${multicast[i].addr}:${multicast[i].port}` }
            });
            tasks.push(task);
        }
        await Promise.all(tasks);  // 都要停止成功才成，否则可重试
        await this.transfer.dropMembership(this.settings.multicast);
    }
    // 组播扫描 ////////////////////////////////////////////////////////////

    // IP扫描 ////////////////////////////////////////////////////////////
    async startIpSpecifiedDiscover({ ip } = {}) {
        // ip 三种传入形式：
        // 1. 字符串："x.x.x.x"：具体某个 ip
        // 2. 字符串："x.x.x.x , y.y.y.y"：某个 ip 范围
        // 3. 数组：[/*前两种字符串*/]
        if (Array.isArray(ip)) {
            for (let _ip of ip) await this.startIpSpecifiedDiscover(_ip);
        }
        else {
            let targetIPs;
            // 末尾加一个逗号，如果只能分出一个 ip，则为具体 ip，否则为 ip 范围
            let ipRange = `${ip},`.split(',').map(x => x.trim().replace('0.0.0.0', '')).filter(x => x);
            if (ipRange.length === 1) {
                if (IPV4_REGEXP.test(ipRange[0])) {
                    targetIPs = ipRange;
                }
                else {
                    throw new VError('invalid ip: {ip}', { ip });
                }
            }
            // 如果分出不是 2 个 ip，则为无效的 ip 范围
            else if (ipRange.length === 2) {
                // 且这两个 ip 应都是合法 ip
                let [startIp, endIp] = ipRange;
                // 且这个 ip 范围内的 ip 数量不应超过 1000 个
                if (IPV4_REGEXP.test(startIp) && IPV4_REGEXP.test(endIp)) {
                    if (parseIPInt(endIp) - parseIPInt(startIp) <= 1000) {
                        targetIPs = getIPRange(startIp, endIp);
                    }
                    else {
                        throw new VError('too large ip range: {ip}(more than 1000 IPs)', { ip });
                    }
                }
                else {
                    throw new VError('invalid ip range: {ip}', { ip });
                }
            }
            else {
                throw new VError('invalid ip range: {ip}', { ip });
            }

            // 发送间隔应大于 ip 数量 * 5ms，避免网络消息过多
            let interval = this.settings.interval && Math.min(targetIPs.length * 5, this.settings.interval);
            if (interval) {
                let sendInvitation = () => {
                    this.sendInvitationByIp(targetIPs);
                    this.setTimeoutId = setTimeout(sendInvitation, interval);
                };
                sendInvitation();
            } else {
                this.sendInvitationByIp(targetIPs);
            }
        }
    }
    async sendInvitationByIp(ip) {
        let settings = this.settings;
        ip = Array.isArray(ip) ? ip : [ip];
        for (let _ip of ip) {
            this.transfer.send({
                data: new InvitationMessage({ SN: 'imdiscoverer' }),
                options: { address: `${_ip}:${settings.deviceUdpPort}` }
            });
        }
    }
    async stopIpSpecifiedDiscover() {
        // 啥也不用做
    }
    // IP扫描 ////////////////////////////////////////////////////////////
}

module.exports = LocalDiscoverer;
