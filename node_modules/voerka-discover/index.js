process.env.NODE_PATH = __dirname;
require('module').Module._initPaths();

global.logger = global.logger || (() => {
    let _logger = {};
    ['info', 'warn', 'debug', 'error'].forEach(type => {
        _logger[type] = (msg, ...args) => {
            (console[type] || console.info)(`[${type.toUpperCase()}] ${new Date().toLocaleString()} ${msg}`, ...args);
        };
    });
    return _logger;
})();

global.VError = Error;

const ms = require('ms');
const jsonpath = require('jsonpath');
const deepMerge = require('merge-deep');
const Deque = require("double-ended-queue");

const { SessionManager } = require('./utils/session');
const { flexibleRequire } = require('./utils/requireutils');

const CloudDiscoverer = require('./discoverer/cloud');
const LocalDiscoverer = require('./discoverer/local');

const { DiscoveredDevice } = require('./lib/voerkaTransfer/protocols/vimp/message');

const STARTED = 0;
const STOPPED = 1;

const DEVICE_IP = Symbol('DEVICE_IP');

const REPORT_CMD = 9;
const EVENTS = {
    DISCOVERED: 'discovered',
    REPORTED: 'reported',
};

const defaultConfig = require('config.default');

class DiscoverService {
	constructor(settings = {}) {
	    this.settings = deepMerge(defaultConfig, settings);
	    this.settings.timeout = ms(this.settings.timeout);
	    this.settings.pubInterval = ms(this.settings.pubInterval);
		this.discoverers = {};
		this.inDiscovering = false;
        this.configSid = 0;
		this.sessions = {};  // 历史遗留，暂保留，以后将使用会话管理器
		// 创建会话管理器
		this.sessionManager = new SessionManager(this.settings.session);
		this.pubishDeviceQueue = new Deque();
		this.isProcessingDeviceQueue = false;
		this.discoveredDevices = {/* [sn]: { ...data, [DEVICE_IP] } */};
		this.eventCallbacks = {/* [event]: [ ...callbacks ] */};
    }
// —— service start & stop ———————————— begin
	async start() {
        await this.loadDiscovers();
        // TODO below is only for test, to be removed when production
        // await this.startDiscoverers();
    }
	async stop() {
        await this.unloadDiscovers();
    }
// —— service start & stop ———————————— end

// —— service props getter ———————————— begin
	/**
	 * 应用的默认配置(或叫做属性)
	 */
	getDefaultAttrs() {
		return Object.assign(super.getDefaultAttrs(), {
			timeout: '5min',
            pubInterval: '10ms'
		});
	}
// —— service props getter ———————————— end

// —— discoverers load & unload ———————————— begin
    async loadDiscovers() {
        await this.unloadDiscovers();
        let discovers = {
            MQTT: {
                DiscovererClass: CloudDiscoverer,
                settings: this.settings.cloud,
                msgHandler: this.handleMessageFromDiscoverer
            },
            MULTICAST: {
                DiscovererClass: LocalDiscoverer,
                settings: this.settings.local,
                msgHandler: this.handleMessageFromDiscoverer
            }
        };
        let customDiscoverers = this.settings.custom;
        if (customDiscoverers) {
            delete customDiscoverers.MQTT;
            delete customDiscoverers.MULTICAST;
            for (let name in customDiscoverers) {
                let settings = customDiscoverers[name];
                if (!settings) {
                    logger.warn(`Discover <${name}> has no settings and will not be initialized`);
                    continue;
                }
                try {
                    discovers[name] = {
                        DiscovererClass: flexibleRequire(settings.entry),
                        settings,
                        msgHandler: this.handleMessageFromDiscoverer
                    };
                } catch (e) {
                    logger.error(`Error while importing discoverer class from path <${settings.entry}>: ${e.stack}`);
                }
            }
        }
        for (let name in discovers) {
            let { DiscovererClass, settings, msgHandler } = discovers[name];
            if (!(settings.hasOwnProperty('enabled') ? settings.enabled : true)) {
                logger.info(`Discover <${name}> is disabled`);
                continue;
            }
            name = settings.name || name;
            try {
                let discoverer = new DiscovererClass({
                    settings, msgHandler: msgHandler.bind(this, name), sessionManager: this.sessionManager
                });
                await discoverer.load(); // 初始化传输器
                this.discoverers[name] = discoverer;
            } catch (e) {  // 错误被捕获，故不影响其它发现器
                logger.error(`Error while loading discoverer <${name}>: ${e.stack}`);
            }

            if (Object.keys(this.discoverers).length === 0) {
                logger.error(`No one of discovers has been loaded therefore discover service cannot work`);
            }
        }
        // 临时方案，解决表现为如下现象的问题：
        // loadDiscovers 后立即 startDiscoverers 则任何消息都无法传输到网络（组播或云端）
        await new Promise(resolve => setTimeout(resolve, 2000));
    }
    async unloadDiscovers() {
		for (let name in this.discoverers) {
            try {
                let discoverer = this.discoverers[name];
                await discoverer.unload();
                delete this.discoverers[name];
            } catch (e) {  // 错误被捕获，故不影响其它发现器
                logger.error(`Error while unloading discoverer <${name}>: ${e.stack}`);
            }
        }
    }
// —— discoverers load & unload ———————————— end

// —— discoverers start & stop ———————————— begin
    async startDiscoverers(options={}) {
	    let { err } = this.assertScanning(STOPPED); if (err) return { err };
	    // this.startPublishDevice();
	    for (let name in this.discoverers) {
	        try {
	            this.discoverers[name].start(options);
            } catch (e) {
	            logger.warn(`Error starting discover <${name}>: ${e.stack}`);
            }
        }
        // 以下暂不启用，留码查看
	    // let tasks = [];
	    // for (let name in this.discoverers) tasks.push(this.discoverers[name].start(options));
	    // await Promise.all(tasks);  // 发现器都启动才算成功，否则可重试
	    this.setTimeout();
	    this.inDiscovering = true;
	    return { err };
    }
    async stopDiscoverers() {
	    let { err } = this.assertScanning(STARTED); if (err) return { err };
	    this.stopPublishDevice();
	    this.clearTimeout();
	    for (let name in this.discoverers) {
	        try {
	            this.discoverers[name].stop();
            } catch (e) {
	            logger.warn(`Error stopping discover <${name}>: ${e.stack}`);
            }
        }
        // 以下暂不启用，留码查看
	    // let tasks = [];
	    // for (let name in this.discoverers) tasks.push(this.discoverers[name].stop());
	    // await Promise.all(tasks);  // 发现器都停止才算成功，否则可重试
	    this.inDiscovering = false;
	    return { err };
    }
    setTimeout() {
	    if (this.settings.timeout) this.timeoutId = setTimeout(() => { this.stopDiscoverers() }, this.settings.timeout * 1000);
    }
    clearTimeout() {
	    clearTimeout(this.timeoutId);
    }
    resetTimeout() {
	    this.clearTimeout();
	    this.setTimeout();
    }
// —— discoverers start & stop ———————————— end

// —— discoverers config & authorize ———————————— begin
    async configDiscovered(data) {
	    // let { err } = this.assertScanning(STARTED); if (err) return { err };
	    let discoverer = this.discoverers[data.source];
        if (!discoverer) return { err: new VError('Discover source unrecognized') };

        let err = null;
        let targetIP = data.targetIP;

        // 若设备发现来源（source）是组播，则先使用 udp 单播进行配置，不成再使用组播进行配置，每种配置方式遇失败则重试三次
        if (data.source === 'MULTICAST') {
            let configSid = ++this.configSid;
            data.sid = configSid;
            this.sessions[configSid] = {};
            let retryMessage;  // 重试用消息实例，避免重试时对同一条消息的重复实例化
            let configProcess = ({ by = 'udp' } = {}) => {
                return new Promise(async (resolve, reject) => {
                    this.sessions[configSid].configProcess = { resolve, reject };
                    let result = await discoverer.config(data, { message: retryMessage, by, targetIP }).catch(e => reject(e));  // 子promise触发错误，若父promise不catch则报错UnhandledPromiseRejectionWarning
                    if (result && result.err) reject(result.err);  // 同理，虽然不会warning，但这是应用层面的UnhandledPromiseRejectionWarning
                    else retryMessage = retryMessage || result.message;
                });
            };
            let timeoutWatch = () => {
                return new Promise((resolve, reject) => {
                    this.sessions[configSid].timeoutWatch = { resolve, reject };
                    setTimeout(() => { reject(new VError('No responding from device')) }, 500);
                });
            };

            let retryTimes = 3;
            for (let i = retryTimes; ((i === retryTimes) || err) && i--;) {
                ({ err } = (await Promise.all([configProcess({ by: 'udp' }), timeoutWatch()]).catch(e => [{ err: e }]))[0]);
            }
            if (err) {
                retryTimes = 3;
                for (let i = retryTimes; ((i === retryTimes) || err) && i--;) {
                    ({ err } = (await Promise.all([configProcess({ by: 'multicast' }), timeoutWatch()]).catch(e => [{ err: e }]))[0]);
                }
            }
        }
        // 若设备发现来源为其它，则直接调用该第三方设备发现器的配置方法，由其自行处理
        else {
            ({ err } = await discoverer.config(data) || {});
        }
        return { err };
    }
    async authorizeDiscovered(data) {
	    // let { err } = this.assertScanning(STARTED); if (err) return { err };
	    if (!data.sn) return { err: new VError('Device sn illegal') };
	    // if (!data.targetIP) return { err: new VError('Device ip illegal') };
	    let app = VIApps[data.domain];
	    if (!app) return { err: new VError('Device domain unrecognized') };
	    let deviceType = app && app.resourceTypes[data.type];
	    if (!deviceType) return { err: new VError('Device type unrecognized') };

	    let discoveredDevice = this.discoveredDevices[data.sn] || {};
	    // 注：认证设备函数会在手动添加或扫描中认证时调用
        // 手动添加设备时，当前只会输入一个 ip 地址，并且放入 network.{interface}.ip 中
        // 如果需求升级，比如需要输入多个 ip，并且还可以输入网卡名称，则此处应做相应改动
        // 扫描中认证时，则目标设备 ip 从已发现设备记录 this.discoveredDevices 中取出
        // 如果有指定设备 ip 则通过 UDP 点对点配置设备的 mqtt，否则授权失败
	    let targetIP = discoveredDevice[DEVICE_IP] || jsonpath.query(data, '$.network..ip')[0] || data.targetIP;
	    //             ^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^^^^^^
        //                   扫描中进行设备认证                       手动添加设备                   非扫描中进行设备认证
        if (!targetIP) return { err: new VError('Device not discovered and Device ip not given') };

        // 如果已发现该设备，而 data 中没有提供网络信息，那就把它的网络信息填充到 data 中
        if (discoveredDevice.Networks) {
            data.version = discoveredDevice.Version;
            if (!data.hasOwnProperty('network')) {
                data.network = {};
                for (let network of discoveredDevice.Networks) {
                    if (!network.Interface) return { err: new VError('Device network interface is required') };
                    let {
                        Interface: iface,
                        MAC: mac,
                        DHCP: dhcp,
                        IP: ip,
                        SubnetMask: subnetmask,
                        Gateway: gateway,
                        DNS_prefer: dns_prefer,
                        DNS_alter: dns_alter
                    } = network;
                    data.network[iface] = {
                        mac,
                        dhcp,
                        ip,
                        subnetmask,
                        gateway,
                        dns_prefer,
                        dns_alter
                    }
                }
            }
        }

        // delete data.network;  // （待验证，留码查看）网络设置由设备登记时同步，否则手动添加时不知其默认网卡名称

        // 如果发现的设备接入信息中指定了父设备SN，则检查此父设备是否已认证或已发现
        // 如果已认证，则直接认证此子设备；如果未认证但已发现，则先认证此父设备再认证此子设备
        // 如果未认证也未发现，则直接认证失败
        let shouldConfigDiscovered = true;
        let parentDeviceSN = discoveredDevice.Parent || data.parent;
        if (parentDeviceSN) {
            if (await VIServer.isAuthorized({ resourceId: parentDeviceSN, appName: data.domain })) {
                // 如果父设备已认证，则直接通过子设备的认证，不用再发组播消息
                shouldConfigDiscovered = false;
                data.parent = parentDeviceSN;
            } else {
                let discoveredParentDevice = this.discoveredDevices[parentDeviceSN];
                if (discoveredParentDevice) {
                    await this.authorizeDiscovered({ sn: parentDeviceSN, domain: app.domain, type: discoveredParentDevice.Type });
                    data.parent = parentDeviceSN;
                }
                else {
                    return { err: new VError(`The parent device {parentDeviceSN} is not authorized`, { parentDeviceSN }) };
                }
            }
        }

        if (shouldConfigDiscovered) {
            let { broker = '', brokerWS = '', username = '', password = '' } = VIServiceManager.modules['vms'].attrs.transfers.find(x => x.name === 'mqtt') || {};
            // 如果被发现待认证设备接入消息中 MQTT 字段值以 ws:// 开头，
            // 则说明设备期望以 ws 协议连接 mqtt，
            // 认证设备时，服务器应为该设备分配 ws 协议的 mqtt 地址
            broker = discoveredDevice.MQTT && discoveredDevice.MQTT.startsWith('ws://') ? brokerWS : broker;
            username = username === null ? '' : username;
            password = password === null ? '' : password;
            data.mqtt = Object.assign(data.mqtt || {}, { broker: broker.replace('://localhost', `://${VIServer.ip}`), username, password });

            // 如果没有提供设备发现来源，则默认为组播
            // 当设备发现来源为组播时，需要在认证设备之前，通过发现器配置设备的以下信息（应用域 domain 和 mqtt 连接信息）
            // 对设备发现来源为其它（如第三方），则直接调用设备的认证设备方法进行处理
            let { err } = !data.source || data.source === 'MULTICAST' ? await this.configDiscovered({
                sn: data.sn,
                cmd: 1,
                source: 'MULTICAST',
                targetIP,
                payload: {
                    Domain: data.domain,
                    MQTT: broker,
                    MQTT_Username: username,
                    MQTT_Password: password
                }
            }) : {};
            if (err) return { err };
        }

	    return await deviceType.authorizeDevice(data.sn, data);
    }
    async unauthorizeDiscovered(data) {
	    // let { err } = this.assertScanning(STARTED); if (err) return { err };
	    if (!data.sn) return { err: new VError('Device sn illegal') };
	    let app = VIApps[data.domain];
	    if (!app) return { err: new VError('Device domain unrecognized') };
	    let deviceType = app && app.resourceTypes[data.type];
	    if (!deviceType) return { err: new VError('Device type unrecognized') };
	    return await deviceType.unauthorizeDevice(data.sn);
    }
    async isVimpSource(source) {
	    return !source || source === 'MQTT' || source === 'MULTICAST';
    }
// —— discoverers config & authorize ———————————— end

// —— handler for message from discoverer  ———————————— begin
    async handleMessageFromDiscoverer(source, { data: message, context }) {
	    if (source === 'MQTT' || source === 'MULTICAST') {
	        if (message.Cmd === REPORT_CMD) {
	            await this.reportDevice(message);
            }
	        else if (message.Code === undefined) {
	            await this.publishDevice(message, source, context);
            }
            else if (this.sessions[message.Sid]) {
                let err = message.Code === 200 ? null : new Error((message.Payload || {}).message || '');
                let session = this.sessions[message.Sid];
                session.timeoutWatch.resolve({ err });
                session.configProcess.resolve({ err });
            }
        }
        else {
	        await this.publishDevice(message, source, context);
        }
    }
    async reportDevice(message) {
	    let deviceSN = message.payload.SN;
	    logger.debug(`There reported a device: ${deviceSN}`);
        for (let callback of this.eventCallbacks[EVENTS.REPORTED] || []) {
            try {
                callback(deviceSN);
            } catch (e) {
                logger.error(`Callback error on event 'reported': ${e.stack}`);
            }
        }
    }
    async publishDevice(message, source, context) {
        // this.resetTimeout();
        let { err, device } = await this.formatDevice(message, source, context);
        if (err) {
            logger.warn(`Received an invalid discovered device: ${JSON.stringify(message)}\n*${err.message}`);
        }
        else {
            this.pubishDeviceQueue.push(device);
            this.startPublishDevice();  // 有 push 才 start
        }
    }
    async formatDevice(device, source, context) {
	    device.Version = device.Version || '(无)';
	    device.Source = source;
	    let deviceAuthInfo = await this.getAuthInfo(device);
        device.Authorized = !!deviceAuthInfo;
        device.Domain = deviceAuthInfo && deviceAuthInfo.app;
        device.Networks = device.Networks ? device.Networks.map(network => {
            for (let key in network) {
                let item = network[key];
                if(Array.isArray(item)) {
                    network[key] = item.join('.');
                }
            }
            network.DHCP = !!network.DHCP;
            network = Object.assign({
                Interface: 'eth0',
                MAC: '',
                IP: '',
                SubnetMask: '',
                Gateway: '',
                DNS_prefer: '',
                DNS_alter: ''
            }, network);
            return network;
        }) : [];
        device.Parent = (device.Parent || '') && device.Parent.replace(/\0/g,'');  // 去掉空 ascii 字符

	    let invalidMessage = DiscoveredDevice.validate(device);
	    if (invalidMessage) return { err: new Error(invalidMessage) };

	    device[DEVICE_IP] = device.Model.startsWith('MockDev:')
            ? device.Model.replace(/^MockDev:/, '')
            : ((context.rinfo && context.rinfo.address) || (device.Networks[0] && device.Networks[0].IP));
	    this.discoveredDevices[device.SN] = device;

	    // 旧代码，留码查看
        // this.discoveredDevices[device.SN] = device.Model.startsWith('MockDev:')
        //     ? device.Model.replace(/^MockDev:/, '')
        //     : ((context.rinfo && context.rinfo.address) || (device.Networks[0] && device.Networks[0].IP));

        return { device };
    }
    async getAuthInfo(device) {
	    // 可供继承的方法，返回设备认证信息 { app: 认证应用名称, ...其它可扩展 }
	    return {};
    }
    startPublishDevice() {
        if (this.isProcessingDeviceQueue) return;
        this.isProcessingDeviceQueue = true;
        let next = () => {
	        let device = this.pubishDeviceQueue.shift();
	        if (device) {
	            logger.debug(`There discovered a device: ${JSON.stringify(device)}`);
	            // 异步执行
                (async () => {
                    for (let callback of this.eventCallbacks[EVENTS.DISCOVERED] || []) {
                        try {
                            callback(device);
                        } catch (e) {
                            logger.error(`Callback error on event 'discovered': ${e.stack}`);
                        }
                    }
                })();
                if (this.isProcessingDeviceQueue) setTimeout(next, this.settings.pubInterval);
            } else {
	            this.stopPublishDevice();
            }
        };
	    setTimeout(next, this.settings.pubInterval);
    }
    stopPublishDevice() {
	    this.isProcessingDeviceQueue = false;
        this.pubishDeviceQueue.clear();
    }
    on(event, callback) {
	    if (!this.eventCallbacks[event]) this.eventCallbacks[event] = [];
	    Array.isArray(callback) ?
            this.eventCallbacks[event].push(...callback)
            : this.eventCallbacks[event].push(callback);
    }
// —— handler for message from discoverer  ———————————— end

// —— discoverers auxiliaries —— begin
    assertScanning(status) {
        if (status === STOPPED && this.inDiscovering) return { err: new VError('Scanning already started')};
	    if (status === STARTED && !this.inDiscovering) return { err: new VError('Scanning already stopped') };
	    return { err: null };
    }
// —— discoverers auxiliaries —— end

// —— handler for message from global eventbus  ———————————— begin
    /**
     * 处理从全局总线上接收到的消息
     * 处理方式: 直接交给传输器发送出去
     * @param {Object} message 消息体
     */
    // async onNotice(message) {
    //     if (message.event === NOTICE_EVENTS.SERVER_DISCOVER_MODE_ACTIVATE_REQUESTED) {
    //         if (this.inDiscovering) return;
    //         await this.startDiscoverers();
    //         this.inDiscovering = true;
    //         this.node.notice(NOTICE_EVENTS.SERVER_DISCOVER_MODE_ACTIVATED);
    //     }
    //     if (message.event === NOTICE_EVENTS.SERVER_DISCOVER_MODE_INACTIVATE_REQUESTED) {
    //         if (!this.inDiscovering) return;
    //         await this.stopDiscoverers();
    //         this.inDiscovering = false;
    //         this.node.notice(NOTICE_EVENTS.SERVER_DISCOVER_MODE_INACTIVATED);
    //     }
    // }
// —— handler for message from global eventbus  ———————————— end
}

module.exports = DiscoverService;
