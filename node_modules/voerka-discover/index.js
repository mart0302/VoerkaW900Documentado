process.env.NODE_PATH = __dirname;
require('module').Module._initPaths();

global.logger = global.logger || (() => {
    let _logger = {};
    ['info', 'warn', 'debug', 'error'].forEach(type => {
        _logger[type] = (msg, ...args) => {
            (console[type] || console.info)(`[${type.toUpperCase()}] ${new Date().toLocaleString()} ${msg}`, ...args);
        };
    });
    return _logger;
})();

global.VError = Error;

const ms = require('ms');
const jsonpath = require('jsonpath');
const deepMerge = require('merge-deep');
const Deque = require("double-ended-queue");

const { SessionManager } = require('./utils/session');
const { flexibleRequire } = require('./utils/requireutils');

const CloudDiscoverer = require('./discoverer/cloud');
const LocalDiscoverer = require('./discoverer/local');

const { DiscoveredDevice } = require('./lib/voerkaTransfer/protocols/vimp/message');

const STARTED = 0;
const STOPPED = 1;

const DEVICE_IP = Symbol('DEVICE_IP');

const REPORT_CMD = 9;
const EVENTS = {
    DISCOVERED: 'discovered',
    REPORTED: 'reported',
};

const defaultConfig = require('config.default');

class DiscoverService {
	constructor(settings = {}) {
	    this.settings = deepMerge(defaultConfig, settings);
	    this.settings.timeout = ms(this.settings.timeout);
	    this.settings.pubInterval = ms(this.settings.pubInterval);
		this.discoverers = {};
		this.inDiscovering = false;
        this.configSid = 0;
		this.sessions = {};  // Legado histórico, retenido temporalmente, el gestor de sesiones se utilizará en el futuro
		// Crear un administrador de sesiones
		this.sessionManager = new SessionManager(this.settings.session);
		this.pubishDeviceQueue = new Deque();
		this.isProcessingDeviceQueue = false;
		this.discoveredDevices = {/* [sn]: { ...data, [DEVICE_IP] } */};
		this.eventCallbacks = {/* [event]: [ ...callbacks ] */};
    }
// —— service start & stop ———————————— begin
	async start() {
        await this.loadDiscovers();
        // TODO below is only for test, to be removed when production
        // await this.startDiscoverers();
    }
	async stop() {
        await this.unloadDiscovers();
    }
// —— service start & stop ———————————— end

// —— service props getter ———————————— begin
	/**
	 * La configuración (o propiedades) predeterminada de la aplicación
	 */
	getDefaultAttrs() {
		return Object.assign(super.getDefaultAttrs(), {
			timeout: '5min',
            pubInterval: '10ms'
		});
	}
// —— service props getter ———————————— end

// —— discoverers load & unload ———————————— begin
    async loadDiscovers() {
        await this.unloadDiscovers();
        let discovers = {
            MQTT: {
                DiscovererClass: CloudDiscoverer,
                settings: this.settings.cloud,
                msgHandler: this.handleMessageFromDiscoverer
            },
            MULTICAST: {
                DiscovererClass: LocalDiscoverer,
                settings: this.settings.local,
                msgHandler: this.handleMessageFromDiscoverer
            }
        };
        let customDiscoverers = this.settings.custom;
        if (customDiscoverers) {
            delete customDiscoverers.MQTT;
            delete customDiscoverers.MULTICAST;
            for (let name in customDiscoverers) {
                let settings = customDiscoverers[name];
                if (!settings) {
                    logger.warn(`Discover <${name}> has no settings and will not be initialized`);
                    continue;
                }
                try {
                    discovers[name] = {
                        DiscovererClass: flexibleRequire(settings.entry),
                        settings,
                        msgHandler: this.handleMessageFromDiscoverer
                    };
                } catch (e) {
                    logger.error(`Error while importing discoverer class from path <${settings.entry}>: ${e.stack}`);
                }
            }
        }
        for (let name in discovers) {
            let { DiscovererClass, settings, msgHandler } = discovers[name];
            if (!(settings.hasOwnProperty('enabled') ? settings.enabled : true)) {
                logger.info(`Discover <${name}> is disabled`);
                continue;
            }
            name = settings.name || name;
            try {
                let discoverer = new DiscovererClass({
                    settings, msgHandler: msgHandler.bind(this, name), sessionManager: this.sessionManager
                });
                await discoverer.load(); // Inicializar el transporte
                this.discoverers[name] = discoverer;
            } catch (e) {  // Se detecta el error para que no afecte a otros descubridores.
                logger.error(`Error while loading discoverer <${name}>: ${e.stack}`);
            }

            if (Object.keys(this.discoverers).length === 0) {
                logger.error(`No one of discovers has been loaded therefore discover service cannot work`);
            }
        }
        // Solución temporal para resolver el problema manifestado como los siguientes fenómenos:
        // Si inicia Discoverers inmediatamente después de cargar Discovers, no se podrán transmitir mensajes a la red (multidifusión o nube).
        await new Promise(resolve => setTimeout(resolve, 2000));
    }
    async unloadDiscovers() {
		for (let name in this.discoverers) {
            try {
                let discoverer = this.discoverers[name];
                await discoverer.unload();
                delete this.discoverers[name];
            } catch (e) {  // Se detecta el error para que no afecte a otros descubridores.
                logger.error(`Error while unloading discoverer <${name}>: ${e.stack}`);
            }
        }
    }
// —— discoverers load & unload ———————————— end

// —— discoverers start & stop ———————————— begin
    async startDiscoverers(options={}) {
	    let { err } = this.assertScanning(STOPPED); if (err) return { err };
	    // this.startPublishDevice();
	    for (let name in this.discoverers) {
	        try {
	            this.discoverers[name].start(options);
            } catch (e) {
	            logger.warn(`Error starting discover <${name}>: ${e.stack}`);
            }
        }
        // Lo siguiente aún no está habilitado, deje el código para verlo
	    // let tasks = [];
	    // for (let name in this.discoverers) tasks.push(this.discoverers[name].start(options));
	    // await Promise.all(tasks);  // El descubrimiento solo es exitoso si se inician todos los descubridores; de lo contrario, puede volver a intentarlo.
	    this.setTimeout();
	    this.inDiscovering = true;
	    return { err };
    }
    async stopDiscoverers() {
	    let { err } = this.assertScanning(STARTED); if (err) return { err };
	    this.stopPublishDevice();
	    this.clearTimeout();
	    for (let name in this.discoverers) {
	        try {
	            this.discoverers[name].stop();
            } catch (e) {
	            logger.warn(`Error stopping discover <${name}>: ${e.stack}`);
            }
        }
        // Lo siguiente aún no está habilitado, deje el código para verlo
	    // let tasks = [];
	    // for (let name in this.discoverers) tasks.push(this.discoverers[name].stop());
	    // await Promise.all(tasks);  // El descubrimiento es exitoso solo cuando todos los descubridores se detienen, de lo contrario, puede volver a intentarlo.
	    this.inDiscovering = false;
	    return { err };
    }
    setTimeout() {
	    if (this.settings.timeout) this.timeoutId = setTimeout(() => { this.stopDiscoverers() }, this.settings.timeout * 1000);
    }
    clearTimeout() {
	    clearTimeout(this.timeoutId);
    }
    resetTimeout() {
	    this.clearTimeout();
	    this.setTimeout();
    }
// —— discoverers start & stop ———————————— end

// —— discoverers config & authorize ———————————— begin
    async configDiscovered(data) {
	    // let { err } = this.assertScanning(STARTED); if (err) return { err };
	    let discoverer = this.discoverers[data.source];
        if (!discoverer) return { err: new VError('Discover source unrecognized') };

        let err = null;
        let targetIP = data.targetIP;

        // Si el dispositivo detecta que la fuente es multidifusión, primero utilizará unidifusión UDP para configurarlo y, luego, utilizará multidifusión para configurarlo si falla. Cada método de configuración se volverá a intentar tres veces si falla.
        if (data.source === 'MULTICAST') {
            let configSid = ++this.configSid;
            data.sid = configSid;
            this.sessions[configSid] = {};
            let retryMessage;  // Vuelva a intentar la instancia del mensaje para evitar la creación repetida de la misma instancia del mensaje durante los reintentos.
            let configProcess = ({ by = 'udp' } = {}) => {
                return new Promise(async (resolve, reject) => {
                    this.sessions[configSid].configProcess = { resolve, reject };
                    let result = await discoverer.config(data, { message: retryMessage, by, targetIP }).catch(e => reject(e));  // La promesa del niño provoca un error. Si no se captura la promesa principal, se informa un error UnhandledPromiseRejectionWarning.
                    if (result && result.err) reject(result.err);  // De manera similar, aunque no hay ninguna advertencia, se trata de un UnhandledPromiseRejectionWarning en el nivel de aplicación.
                    else retryMessage = retryMessage || result.message;
                });
            };
            let timeoutWatch = () => {
                return new Promise((resolve, reject) => {
                    this.sessions[configSid].timeoutWatch = { resolve, reject };
                    setTimeout(() => { reject(new VError('No responding from device')) }, 500);
                });
            };

            let retryTimes = 3;
            for (let i = retryTimes; ((i === retryTimes) || err) && i--;) {
                ({ err } = (await Promise.all([configProcess({ by: 'udp' }), timeoutWatch()]).catch(e => [{ err: e }]))[0]);
            }
            if (err) {
                retryTimes = 3;
                for (let i = retryTimes; ((i === retryTimes) || err) && i--;) {
                    ({ err } = (await Promise.all([configProcess({ by: 'multicast' }), timeoutWatch()]).catch(e => [{ err: e }]))[0]);
                }
            }
        }
        // Si la fuente de descubrimiento del dispositivo es otra, llame directamente al método de configuración del descubridor de dispositivos de terceros y deje que lo gestione por sí solo.
        else {
            ({ err } = await discoverer.config(data) || {});
        }
        return { err };
    }
    async authorizeDiscovered(data) {
	    // let { err } = this.assertScanning(STARTED); if (err) return { err };
	    if (!data.sn) return { err: new VError('Device sn illegal') };
	    // if (!data.targetIP) return { err: new VError('Device ip illegal') };
	    let app = VIApps[data.domain];
	    if (!app) return { err: new VError('Device domain unrecognized') };
	    let deviceType = app && app.resourceTypes[data.type];
	    if (!deviceType) return { err: new VError('Device type unrecognized') };

	    let discoveredDevice = this.discoveredDevices[data.sn] || {};
	  // Nota: La función del dispositivo de autenticación se llamará al agregar o escanear manualmente para autenticación
        // Al agregar un dispositivo manualmente, actualmente solo se ingresará una dirección IP y se colocará en network.{interface}.ip
        // Si se actualizan los requisitos, por ejemplo, necesita ingresar varias direcciones IP y el nombre de la tarjeta de red, debe realizar los cambios correspondientes aquí
        // Al autenticarse durante el escaneo, la IP del dispositivo de destino se toma del registro del dispositivo descubierto this.discoveredDevices
        // Si se especifica la IP del dispositivo, configure el mqtt del dispositivo a través de UDP punto a punto, de lo contrario la autorización falla
	    let targetIP = discoveredDevice[DEVICE_IP] || jsonpath.query(data, '$.network..ip')[0] || data.targetIP;
	    //             ^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^^^^^^
        //                  Autenticación del dispositivo durante el escaneo                   Agregar manualmente un dispositivo para autenticarlo sin escanearlo
        if (!targetIP) return { err: new VError('Device not discovered and Device ip not given') };

        // Si se encuentra el dispositivo y la información de red no se proporciona en los datos, complete la información de red en los datos
        if (discoveredDevice.Networks) {
            data.version = discoveredDevice.Version;
            if (!data.hasOwnProperty('network')) {
                data.network = {};
                for (let network of discoveredDevice.Networks) {
                    if (!network.Interface) return { err: new VError('Device network interface is required') };
                    let {
                        Interface: iface,
                        MAC: mac,
                        DHCP: dhcp,
                        IP: ip,
                        SubnetMask: subnetmask,
                        Gateway: gateway,
                        DNS_prefer: dns_prefer,
                        DNS_alter: dns_alter
                    } = network;
                    data.network[iface] = {
                        mac,
                        dhcp,
                        ip,
                        subnetmask,
                        gateway,
                        dns_prefer,
                        dns_alter
                    }
                }
            }
        }

        // delete data.network;  // (Para verificar, deje el código para ver) Las configuraciones de red se sincronizan cuando se registra el dispositivo, de lo contrario, el nombre de la tarjeta de red predeterminada es desconocido al agregarlo manualmente
// Si el número de serie del dispositivo principal se especifica en la información de acceso del dispositivo descubierto, verifique si el dispositivo principal ha sido autenticado o descubierto
        // Si se ha autenticado, autentica este dispositivo secundario directamente; Si no se ha autenticado pero se ha descubierto, autentique primero este dispositivo principal y luego autentique este dispositivo secundario.
        // Si no se autentica y no se encuentra, la autenticación fallará directamente
        let shouldConfigDiscovered = true;
        let parentDeviceSN = discoveredDevice.Parent || data.parent;
        if (parentDeviceSN) {
            if (await VIServer.isAuthorized({ resourceId: parentDeviceSN, appName: data.domain })) {
                // Si el dispositivo principal ha sido autenticado, el dispositivo secundario se autenticará directamente sin enviar mensajes de multidifusión.
                shouldConfigDiscovered = false;
                data.parent = parentDeviceSN;
            } else {
                let discoveredParentDevice = this.discoveredDevices[parentDeviceSN];
                if (discoveredParentDevice) {
                    await this.authorizeDiscovered({ sn: parentDeviceSN, domain: app.domain, type: discoveredParentDevice.Type });
                    data.parent = parentDeviceSN;
                }
                else {
                    return { err: new VError(`The parent device {parentDeviceSN} is not authorized`, { parentDeviceSN }) };
                }
            }
        }

        if (shouldConfigDiscovered) {
            let { broker = '', brokerWS = '', username = '', password = '' } = VIServiceManager.modules['vms'].attrs.transfers.find(x => x.name === 'mqtt') || {};
            // Si el valor del campo MQTT en el mensaje de acceso del dispositivo que se va a autenticar comienza con ws://,
            // Esto significa que el dispositivo espera conectarse a mqtt utilizando el protocolo ws.
            // Al autenticar un dispositivo, el servidor debe asignarle al dispositivo una dirección mqtt del protocolo ws
            broker = discoveredDevice.MQTT && discoveredDevice.MQTT.startsWith('ws://') ? brokerWS : broker;
            username = username === null ? '' : username;
            password = password === null ? '' : password;
            data.mqtt = Object.assign(data.mqtt || {}, { broker: broker.replace('://localhost', `://${VIServer.ip}`), username, password });

            // Si no se proporciona ninguna fuente de descubrimiento de dispositivos, el valor predeterminado es multidifusión
            // Cuando la fuente de descubrimiento del dispositivo es multidifusión, debe configurar la siguiente información del dispositivo (dominio de aplicación e información de conexión mqtt) a través del descubridor antes de autenticar el dispositivo.
            // Si la fuente de descubrimiento del dispositivo es otra (por ejemplo, un tercero), llame directamente al método de autenticación del dispositivo para procesarlo
            let { err } = !data.source || data.source === 'MULTICAST' ? await this.configDiscovered({
                sn: data.sn,
                cmd: 1,
                source: 'MULTICAST',
                targetIP,
                payload: {
                    Domain: data.domain,
                    MQTT: broker,
                    MQTT_Username: username,
                    MQTT_Password: password
                }
            }) : {};
            if (err) return { err };
        }

	    return await deviceType.authorizeDevice(data.sn, data);
    }
    async unauthorizeDiscovered(data) {
	    // let { err } = this.assertScanning(STARTED); if (err) return { err };
	    if (!data.sn) return { err: new VError('Device sn illegal') };
	    let app = VIApps[data.domain];
	    if (!app) return { err: new VError('Device domain unrecognized') };
	    let deviceType = app && app.resourceTypes[data.type];
	    if (!deviceType) return { err: new VError('Device type unrecognized') };
	    return await deviceType.unauthorizeDevice(data.sn);
    }
    async isVimpSource(source) {
	    return !source || source === 'MQTT' || source === 'MULTICAST';
    }
// —— discoverers config & authorize ———————————— end

// —— handler for message from discoverer  ———————————— begin
    async handleMessageFromDiscoverer(source, { data: message, context }) {
	    if (source === 'MQTT' || source === 'MULTICAST') {
	        if (message.Cmd === REPORT_CMD) {
	            await this.reportDevice(message);
            }
	        else if (message.Code === undefined) {
	            await this.publishDevice(message, source, context);
            }
            else if (this.sessions[message.Sid]) {
                let err = message.Code === 200 ? null : new Error((message.Payload || {}).message || '');
                let session = this.sessions[message.Sid];
                session.timeoutWatch.resolve({ err });
                session.configProcess.resolve({ err });
            }
        }
        else {
	        await this.publishDevice(message, source, context);
        }
    }
    async reportDevice(message) {
	    let deviceSN = message.payload.SN;
	    logger.debug(`There reported a device: ${deviceSN}`);
        for (let callback of this.eventCallbacks[EVENTS.REPORTED] || []) {
            try {
                callback(deviceSN);
            } catch (e) {
                logger.error(`Callback error on event 'reported': ${e.stack}`);
            }
        }
    }
    async publishDevice(message, source, context) {
        // this.resetTimeout();
        let { err, device } = await this.formatDevice(message, source, context);
        if (err) {
            logger.warn(`Received an invalid discovered device: ${JSON.stringify(message)}\n*${err.message}`);
        }
        else {
            this.pubishDeviceQueue.push(device);
            this.startPublishDevice();  // Iniciar solo cuando haya un empujón
        }
    }
    async formatDevice(device, source, context) {
	    device.Version = device.Version || '(无)';
	    device.Source = source;
	    let deviceAuthInfo = await this.getAuthInfo(device);
        device.Authorized = !!deviceAuthInfo;
        device.Domain = deviceAuthInfo && deviceAuthInfo.app;
        device.Networks = device.Networks ? device.Networks.map(network => {
            for (let key in network) {
                let item = network[key];
                if(Array.isArray(item)) {
                    network[key] = item.join('.');
                }
            }
            network.DHCP = !!network.DHCP;
            network = Object.assign({
                Interface: 'eth0',
                MAC: '',
                IP: '',
                SubnetMask: '',
                Gateway: '',
                DNS_prefer: '',
                DNS_alter: ''
            }, network);
            return network;
        }) : [];
        device.Parent = (device.Parent || '') && device.Parent.replace(/\0/g,'');  // 去掉空 ascii 字符

	    let invalidMessage = DiscoveredDevice.validate(device);
	    if (invalidMessage) return { err: new Error(invalidMessage) };

	    device[DEVICE_IP] = device.Model.startsWith('MockDev:')
            ? device.Model.replace(/^MockDev:/, '')
            : ((context.rinfo && context.rinfo.address) || (device.Networks[0] && device.Networks[0].IP));
	    this.discoveredDevices[device.SN] = device;

	    // Código antiguo, dejar el código para ver
        // this.discoveredDevices[device.SN] = device.Model.startsWith('MockDev:')
        //     ? device.Model.replace(/^MockDev:/, '')
        //     : ((context.rinfo && context.rinfo.address) || (device.Networks[0] && device.Networks[0].IP));

        return { device };
    }
    async getAuthInfo(device) {
	    // Método heredado, devuelve información de autenticación del dispositivo { app: nombre de la aplicación de autenticación, ...otro extensible }
	    return {};
    }
    startPublishDevice() {
        if (this.isProcessingDeviceQueue) return;
        this.isProcessingDeviceQueue = true;
        let next = () => {
	        let device = this.pubishDeviceQueue.shift();
	        if (device) {
	            logger.debug(`There discovered a device: ${JSON.stringify(device)}`);
	            // Ejecución asincrónica
                (async () => {
                    for (let callback of this.eventCallbacks[EVENTS.DISCOVERED] || []) {
                        try {
                            callback(device);
                        } catch (e) {
                            logger.error(`Callback error on event 'discovered': ${e.stack}`);
                        }
                    }
                })();
                if (this.isProcessingDeviceQueue) setTimeout(next, this.settings.pubInterval);
            } else {
	            this.stopPublishDevice();
            }
        };
	    setTimeout(next, this.settings.pubInterval);
    }
    stopPublishDevice() {
	    this.isProcessingDeviceQueue = false;
        this.pubishDeviceQueue.clear();
    }
    on(event, callback) {
	    if (!this.eventCallbacks[event]) this.eventCallbacks[event] = [];
	    Array.isArray(callback) ?
            this.eventCallbacks[event].push(...callback)
            : this.eventCallbacks[event].push(callback);
    }
// —— handler for message from discoverer  ———————————— end

// —— discoverers auxiliaries —— begin
    assertScanning(status) {
        if (status === STOPPED && this.inDiscovering) return { err: new VError('Scanning already started')};
	    if (status === STARTED && !this.inDiscovering) return { err: new VError('Scanning already stopped') };
	    return { err: null };
    }
// —— discoverers auxiliaries —— end

// —— handler for message from global eventbus  ———————————— begin
    /**
     *Procesar mensajes recibidos del bus global
     * Método de procesamiento: enviarlo directamente al transmisor.
     * @param {Object} message cuerpo del mensaje
     */
    // async onNotice(message) {
    //     if (message.event === NOTICE_EVENTS.SERVER_DISCOVER_MODE_ACTIVATE_REQUESTED) {
    //         if (this.inDiscovering) return;
    //         await this.startDiscoverers();
    //         this.inDiscovering = true;
    //         this.node.notice(NOTICE_EVENTS.SERVER_DISCOVER_MODE_ACTIVATED);
    //     }
    //     if (message.event === NOTICE_EVENTS.SERVER_DISCOVER_MODE_INACTIVATE_REQUESTED) {
    //         if (!this.inDiscovering) return;
    //         await this.stopDiscoverers();
    //         this.inDiscovering = false;
    //         this.node.notice(NOTICE_EVENTS.SERVER_DISCOVER_MODE_INACTIVATED);
    //     }
    // }
// —— handler for message from global eventbus  ———————————— end
}

module.exports = DiscoverService;
