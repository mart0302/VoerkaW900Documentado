const msgpack = require('msgpack5')();
const vstruct = require('varstruct');
const JSONbig = require('json-bigint')({ useNativeBigInt: true });
// TEMP: Evita temporalmente el error cuando jsonbig analiza decimales
const JSONbigParse = function (...args) {
    try {
        return JSONbig.parse(...args);
    } catch (e) {
        return JSON.parse(...args);
    }
};
const ajv = new (require('ajv'))({ allErrors: true, jsonPointers: true, useDefaults: true });
require('ajv-errors')(ajv);
function isJson(data, spaceLimit = Infinity) {
    let spaceSymbols, braceLeft, braceRight, bracketLeft, bracketRight;
    if (data instanceof Buffer) {
        spaceSymbols = [0x0a, 0x0d, 0x20];
        braceLeft = 0x7b; braceRight = 0x7d;
        bracketLeft = 0x5b; bracketRight = 0x5d;
    } else if (typeof data === 'string') {
        spaceSymbols = ['\n', '\r', ' '];
        braceLeft = '{'; braceRight = '}';
        bracketLeft = '['; bracketRight = ']';
    } else {
        return false;
    }
    let len = data.length, leftPass = false, rightPass = false;
    for (let i = len; i-- && i < spaceLimit;) {
        if (!rightPass) {
            if (spaceSymbols.indexOf(data[i]) === -1) {
                if (data[i] === braceRight || data[i] === bracketRight) rightPass = true;
                else return false;
            }
        }
        if (!leftPass) {
            let j = len - i - 1;
            if (spaceSymbols.indexOf(data[j]) === -1) {
                if (data[j] === braceLeft || data[j] === bracketLeft) leftPass = true;
                else return false;
            }
        }
    }
    return leftPass && rightPass;
}

class MessageBase {
    static get sidKey() {
        return true;  //Especifique la clave de identificación de sesión para este mensaje. Si se establece en 'sid' o verdadero, la clave de identificación de la sesión será sid; si se establece en falso, la identificación de la sesión no se incluirá.
    }
    static get responseMessageClass() {
        return false;  //Especifique el tipo de mensaje de respuesta correspondiente a este mensaje. falso o vacío = sin restricción. Se aplica a las respuestas de mensajes cuando se transmiten indiscriminadamente con ID de sesión repetidos.
    }
    static get struct() {
        return [];
    }
    static get schema() {
        return {};
    }
    constructor(body={}) {
        let inValidMessage = this.constructor.validate(body);
        if (inValidMessage) throw new Error(inValidMessage);
        this._bodyHandler = {
            set: (obj, prop, value) => {
                this[prop] = value;
                this[prop] = this.__body[prop] = value;
                obj[prop] = value;
                return true;
            },
            // deleteProperty(target, prop) {
            //     delete this[prop];
            //     delete target[prop];
            //     return true;
            // }
        };
        this.body = this.__body = body || {};
        this.struct = vstruct(this.constructor.struct);
    }
    get body() {
        //mantenerse sincronizado
        for (let key in this._body) {
            if (this.hasOwnProperty(key)) {
                this._body[key] = this.__body[key] = this[key];
            }
            else {
                delete this._body[key];
                delete this.__body[key];
            }
        }
        return this._body;
    }
    set body(value) {
        for (let key in this._body) {
            delete this[key];
        }
        this._body = new Proxy(value, this._bodyHandler);
        this.__body = value;
        for (let key in value) {
            this[key] = value[key];
        }
    }
    toString() {
        return JSONbig.stringify(this.__body);
    }
    toJson() {
        return this.body;
    }
    toBuffer() {
        return Buffer.from(JSONbig.stringify(this.__body));
    }
    toStructBuffer() {
        return this.constructor.customStructEncoder(this.__body) || this.struct.encode(this.__body);
    }
    toMsgPack() {
        return msgpack.encode(this.__body);
    }
    static validate(data) {
        let dataValidate = ajv.compile(this.schema);
        let isValid = dataValidate(data);
        if (!isValid) {
            return `${dataValidate.errors[0].dataPath} ${dataValidate.errors[0].message}`;
        }
    }

    static customStructEncoder(data) {}
    static customStructDecoder(data) {}
}

//Serializar datos en MsgPack o Buffer no estructurado
function msgPackSerialize(message, options={ debug: false }) {
	if (!message) return '';
    if (options.debug) {  // to unstructured Buffer
        return message.toBuffer ? message.toBuffer() : JSONbig.stringify(message);
    } else {  // MsgPack
        return message.toMsgPack();
    }
}

// Deserializar MsgPack o cadena JSON o búfer JSON
function msgPackDeserialize(data, options={ debug: false }) {
	if (!data || data.length === 0) return {};
    let unpacked;
	let err;
	if (isJson(data)) {
		// Independientemente de si se depura o no, intenta usar JSON para decodificar
		try {
		    unpacked = JSONbigParse(data);
        } catch (e) {
		    err = e;
        }
	} else {
		try {  // De lo contrario, intente usar msgpack para decodificar
			unpacked = msgpack.decode(data);
			// Y tratar de convertir a JSON después de decodificar
			try {
				unpacked = JSONbigParse(unpacked);
			} catch (e) {/* Si no se puede convertir a JSON, déjelo como está. */}
		} catch (e) {  // Informar un error si falla
			err = e;
		}
	}
	if (err) {
		throw err;
	}
	if (unpacked) {
	    unpacked.__sidKey__ = MessageBase.sidKey;
	    unpacked.__msgClass__ = MessageBase;
    }
	return unpacked;
}

//Serializar datos en un búfer estructurado o no estructurado
function msgStructBufferSerialize(message) {
	return message.toStructBuffer();
}

// Deserializar MsgPack o cadena JSON o búfer JSON
function msgStructBufferDeserialize(msgClass, data) {
    if (!msgClass) return;
    let msgClasses = Array.isArray(msgClass) ? msgClass : [msgClass];
	let unpacked;
	let err;
	if (isJson(data)) {
		try {
		    unpacked = JSONbigParse(data);
        } catch (e) {
		    err = e;
        }
	} else {
		for (let i in msgClasses) {
		    try {  // De lo contrario, intente utilizar la solución struct
                unpacked = msgClass.customStructDecoder(data) || vstruct(msgClasses[i].struct).decode(data);
                // Y tratar de convertir a JSON después de decodificar
                try {
                    unpacked = JSONbigParse(unpacked);
                } catch (e) {/*Si no se puede convertir a JSON, déjelo como está. */}
                break;
            } catch (e) {  // Informar un error si falla
                err = e;
            }
        }
	}
	if (err) {
		throw err;
	}
	if (unpacked) {
	    unpacked.__sidKey__ = msgClass.sidKey;
	    unpacked.__msgClass__ = msgClass;
    }
	return unpacked;
}

module.exports = {
    isJson,
    MessageBase,
    msgPackSerialize,
    msgPackDeserialize,
    msgStructBufferSerialize,
    msgStructBufferDeserialize
};