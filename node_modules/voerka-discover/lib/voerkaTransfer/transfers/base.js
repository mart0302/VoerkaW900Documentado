/*

// Importar la clase base, los nombres de eventos y de estados
const { TransferBase, transferEvent, transferStatus } = require('/path/to/transfer/base');

// Clase que implementa el transmisor
class XXXTransfer extends TransferBase {

    // Constructor
    constructor(settings = { name, serializer, deserializer }) {
        // serializer: ruta o instancia del serializador
        // deserializer: ruta o instancia del deserializador
        super(settings);
    }

    // Función de inicialización
    async init() {
        // Aquí puedes escribir lógica de inicialización que requiera `await`
        // y que no se puede ejecutar directamente en el constructor
    }

    // Métodos que deben implementarse:

    // Método de conexión
    async connect() {
        // Aquí deberías registrar los callbacks de eventos
        // Ejemplo: client.on('connect', this.onConnected.bind(this));
    }

    // Método de desconexión
    async disconnect() {}

    // Método de reconexión (opcional)
    async reconnect() {}

    // Método para enviar datos
    async send({ data, originalData, options = {} } = {}) {
        // data: datos ya serializados/codificados/comprimidos (Buffer o String), listos para enviarse
        // originalData: datos originales antes del procesamiento
        // options: opciones adicionales de envío
    }

    // Callbacks a registrar:

    // Callback al conectar
    async onConnected() {}

    // Callback al desconectar
    async onDisconnected() {}

    // Callback al reconectar
    async reconnect() {}

    // Callback en caso de error
    async onError(e) {}

    // Callback al recibir datos
    async onData() {}
}


 */

const ms = require('ms');
const assert = require('assert');
const { hook } = require('../utils/functools');
const { flexibleRequire } = require('../utils/requireutils');
const { SessionManager } = require('../utils/session');

// Valor de estado del transmisor
const transferStatus = {
	INITIALIZING : Symbol('INITIALIZING'),  // Inicializando
	INITIALIZED  : Symbol('INITIALIZED'),   // Inicializado
	CONNECTING   : Symbol('CONNECTING'),    // conectando
	CONNECTED    : Symbol('CONNECTED'),     // Conectado (en ejecución)
	RECONNECTING : Symbol('RECONNECTING'),  // Reconectando
	DISCONNECTING: Symbol('DISCONNECTING'), // Desconectando
	DISCONNECTED : Symbol('DISCONNECTED'),  // desconectado
	ERROR        : Symbol('ERROR'),         // Ocurrió un error
};

const transferEvent = {
    connected   : 'connected',
    disconnected: 'disconnected',
    data        : 'data',
    error       : 'error',
};

// 传输器状态文本
const transferStatusText = {
	[transferStatus.INITIALIZING] : 'initializing',              // Inicializando
	[transferStatus.INITIALIZED]  : 'initialized',               // Inicializado
	[transferStatus.CONNECTING]   : 'connecting',                // conectando
	[transferStatus.CONNECTED]    : transferEvent.connected,     // Conectado (en ejecución)
	[transferStatus.RECONNECTING] : 'connecting',                // Reconectando
	[transferStatus.DISCONNECTING]: 'disconnecting',             // Desconectando
	[transferStatus.DISCONNECTED] : transferEvent.disconnected,  // desconectado
	[transferStatus.ERROR]        : transferEvent.error,         // Ocurrió un error
};

const _BEFORE_INIT = Symbol('_beforeInit');  // antes de llamar a init
const _AFTER_INIT = Symbol('_afterInit');  // después de todo init mientras antes init real
const _ON_INIT = Symbol('_onInit');  // after real init
const _BEFORE_CONNECT = Symbol('_beforeConnect');
const _AFTER_CONNECT = Symbol('_afterConnect');
const _ON_CONNECTED = Symbol('_onConnected');
const _BEFORE_DISCONNECT = Symbol('_beforeDisconnect');
const _AFTER_DISCONNECT = Symbol('_afterDisconnect');
const _ON_DISCONNECTED = Symbol('_onDisconnected');
const _BEFORE_RECONNECT = Symbol('_beforeReconnect');
const _BEFORE_SEND = Symbol('_beforeSend');
const _AFTER_ON_DATA = Symbol('_afterOnData');  // equals to _ON_DATA

// 保护单例不被篡改
const _SINGLETON = Symbol('_singleton');

const TIMEOUT_FLAG = Symbol('TIMEOUT_FLAG');

const idle = (x) => x;
global.logger = global.logger || {
    info: (...args) => console.info('[INFO]', ...args),
    debug: (...args) => console.debug('[DEBUG]', ...args),
    warn: (...args) => console.warn('[WARN]', ...args),
    error: (...args) => console.error('[ERROR]', ...args),
};

//Clase base del transmisor
class TransferBase {
// —— Inicialización del transmisor ———————————— Comenzar
	/**
	 * 
	 * @param {Object} ajustes Configuración del transmisor
	 */
	constructor(settings, sessionManager) {
	    //Soporte singleton
        this.enableSingleton = this.constructor.enableSingleton;
        // Si enableSingleton devuelve verdadero, use el singleton guardado predeterminado; de lo contrario, si no es un valor falso (falso, indefinido, ''), devuelva el resultado de la llamada como singleton        let isSingleTon = typeof this.enableSingleton === 'function' ? this.enableSingleton(this, ...arguments) : this.enableSingleton;
        if (isSingleTon === true) {
            if (this.constructor[_SINGLETON]) return Object.assign(this, this.constructor[_SINGLETON]);
            this.constructor[_SINGLETON] = this;
        }
        else if (isSingleTon) {
            return Object.assign(this, isSingleTon);
        }

        // error
        this.error = null;

		//Configuración
		this.settings = Object.assign({}, this.constructor.__proto__.prototype.defaultSettings(), this.defaultSettings(), settings);
		if (sessionManager) this.sessionManager = sessionManager;
		else {
			this.sessionManager = new SessionManager(this.settings.session);
			this.sessionManager.start();
		}
		// if (!sessionManager) logger.debug(`Transferencia <${this.name}> administrador de sesiones no inicializado`);

		// cliente
		this.endpoint = null;
		this.connectedPromise = {};
		this.disconnectedPromise = {};

		// Lista de funciones de devolución de llamada de eventos
        this.eventCallbacks = {
            [transferEvent.connected]: [],
            [transferEvent.disconnected]: [],
            [transferEvent.data]: [],
            [transferEvent.error]: [],
        };

        // Decorar (habilitar) las capacidades de gestión de estados para las funciones necesarias
        // Nota: Las capacidades de gestión de estado incluyen: cambio de estado y verificación de condición de estado
        // Verificación de la condición del estado, p. ej., no puede volver a conectarse cuando ya está conectado (debe llamar al método de reinicio en su lugar)
		this._enableManageStatus();

		this._changeStatus(transferStatus.INITIALIZING);
		// serializar
        let { serializer, deserializer } = this.settings;
        try {
            this.serialize = serializer ?
                (typeof serializer === 'string' ? flexibleRequire(serializer) : serializer)
                : idle;
        } catch (e) {
            logger.error(`Error while importing serializer for Transfer <${this.displayName}>: ${e.stack}`);
            this._changeStatus(transferStatus.ERROR);
        }
        try {
            this.deserialize = deserializer ?
                (typeof deserializer === 'string' ? flexibleRequire(deserializer) : deserializer)
                : idle;
        } catch (e) {
            logger.error(`Error while importing deserializer for Transfer <${this.displayName}>: ${e.stack}`);
            this._changeStatus(transferStatus.ERROR);
        }
        this._changeStatus(transferStatus.INITIALIZED);
	}
	/**
	* Función de inicialización
	 * Puede implementarse mediante clases heredadas
	 */
	async init() {

    }
    /**
     * Configuración predeterminada
     * @returns {{name: string, sidKey: string}}
     */
    defaultSettings() {
	    return {
            name: this.constructor.name,
            sidKey: 'sid'
        };
    }
// —— Inicialización del transmisor ———————————— fin

// —— Propiedades del transmisor ———————————— comenzar
	get name() {
		return this.settings.name || this.constructor.name;
	}
	get debug() {
		return this.settings.debug;
	}
	get displayName() {
		return this.settings.name || this.constructor.name;
	}
// —— Propiedades del transmisor ———————————— fin

// —— Estado de funcionamiento del transmisor ———————————— comenzar
	/**
	* Habilitar la gestión del estado de funcionamiento del módulo
	 * Incluye: cambio de estado y verificación de condición de estado.
	 * Por ejemplo: no puedes reiniciar en el estado iniciado (pero debes llamar al método de reinicio)
	 * (Este método se abstrae como un gancho)
	 */
	_enableManageStatus() {
		let onError = e => { this._changeStatus(transferStatus.ERROR, e); };
		hook(this, [
			{
				before: this[_BEFORE_INIT],
				original: this.init,
				after: this[_AFTER_INIT],
				error: onError
			},
			{
				before: this[_BEFORE_CONNECT],
				original: this.connect,
				after: this[_AFTER_CONNECT],
				error: onError
			},
			{
				before: this[_BEFORE_DISCONNECT],
				original: this.disconnect,
				after: this[_AFTER_DISCONNECT],
				error: onError
			},
			{
				before: this[_BEFORE_CONNECT],
				original: this.reconnect,
				after: this[_AFTER_CONNECT],
				error: onError
			},
			{
				before: this[_BEFORE_SEND],
				original: this.send
			},
			{
				original: this.onData,
				after: this[_AFTER_ON_DATA]
			},
			{
				original: this.onConnected,
				after: this[_ON_CONNECTED]
			},
			{
				original: this.onDisconnected,
				after: this[_ON_DISCONNECTED]
			},
			{
				original: this.onReconnecting,
				after: this[_BEFORE_CONNECT]
			},
		]);
	}
	/**
	 * Cambiar estado del módulo
	 * @param {Number} status
	 */
	_changeStatus(status, ...args) {
	    // Sin cambios de estado, sin procesamiento repetido
        if (this.isStatus(status)) return;

	    // Estado anterior
        let prevStatus = this.status;
		// Cambiar estado
		this.status = status;

        // Si el error es un objeto de error, el error también debe configurarse
        // Si ya es una instancia de Error, no es necesario instanciarla nuevamente
        if (status === transferStatus.ERROR) {
            this.error = args[0] instanceof Error ? args[0] : new Error(args[0]);
            // explotación florestal
            logger.error(`Error while ${transferStatusText[prevStatus]} transfer <${this.displayName}>: ${this.error.stack}`);
            // En caso de conexión o desconexión, también deberá finalizarse la promesa relacionada.
            if (prevStatus === transferStatus.CONNECTING && this.connectedPromise) this.connectedPromise.connectedReject(this.error);
            if (prevStatus === transferStatus.DISCONNECTING && this.disconnectedPromise) this.disconnectedPromise.disconnectedReject(this.error);
        }

		// explotación florestal
		if (this.error) {
			logger.info(`Transfer <${this.displayName}> is ${transferStatusText[status]}: ${this.error.stack}`);
		}
		else {
		    logger.info(`Transfer <${this.displayName}> is ${transferStatusText[status]}`);
        }

		// desencadenar devolución de llamada
		this.onChangeStatus(status, ...args);
	}

	/**
	 * Determinar el estado actual
	 * @param {Symbol} status
	 */
	isStatus(status) {
		return this.status === status;
	}
    /**
	 *Llamado después de los cambios de estado
     * @param {Symbol} status 状态码
     */
	onChangeStatus(status, ...args) {
	    this.callback(transferStatusText[status], ...args);
    }

	/**
	 * Estado del módulo listo
	 * Cuando dependas de este módulo, debes comprobarlo tú mismo
	 */
	get isReady() {
		return this.isStatus(transferStatus.CONNECTED);
	}
    /**
     * Confirmar que el módulo está listo
     * @param message
     */
    assertReady(message) {
        assert(this.isReady, message || `Transfer <${this.displayName}> not ready`);
    }
    /**
     * Esperando que el módulo esté listo
     * @returns {Promise<void>}
     */
    async getReady({ timeout } = {}) {
        if (timeout) {
            let result = await Promise.race([
                this.connectedPromise,
                new Promise(resolve => setTimeout(() => resolve(TIMEOUT_FLAG), ms(timeout)))
            ]);
            if (result === TIMEOUT_FLAG) this.assertReady(this.error);
        }
        else await this.connectedPromise;
	}

// ——— Estado de funcionamiento del transmisor ———————————— fin

// —— Gancho privado del transmisor (reservado) ———————————— comenzar
	async [_BEFORE_INIT](...args) {
        this._changeStatus(transferStatus.INITIALIZING, ...args);
    }
	async [_AFTER_INIT](...args) {
        // Una vez completada la inicialización, el estado cambia a "Inicialización completada".
        this._changeStatus(transferStatus.INITIALIZED, ...args);
    }

	async [_BEFORE_CONNECT](...args) {
        // console.log(`[MEOW] Transfer ${this.displayName}(${transferStatusText[this.status]}) is trying to connect`);
	    // Solo puede conectarse cuando el estado sea Inicializado, Desconectado o Error.
	    if (this.isStatus(transferStatus.INITIALIZED) || this.isStatus(transferStatus.DISCONNECTED) || this.isStatus(transferStatus.ERROR)) {
	        // Si el estado actual es Inicialización completada, el estado cambiará a Conectando, de lo contrario será Reconectando.
            this.isStatus(transferStatus.INITIALIZED) ?
                this._changeStatus(transferStatus.CONNECTING, ...args)
                : this._changeStatus(transferStatus.RECONNECTING, ...args);
            // Compatible con conexiones que no admiten espera
            // Crear promesa de conexión
            if (!this.connectedPromise) {
                let connectedResolve, connectedReject;
                this.connectedPromise = new Promise((resolve, reject) => {
                    connectedResolve = resolve;
                    connectedReject = reject;
                });
                this.connectedPromise.connectedResolve = connectedResolve;
                this.connectedPromise.connectedReject = connectedReject;
            }
        }
        else {
	        // console.log(`[MEOW] Transfer ${this.displayName}(${transferStatusText[this.status]}) cannot connect`);
	        // Otro estado puede ser Conectando o Conectado
            // En el caso único, las conexiones repetidas no informarán un error y serán ignoradas directamente.
	        return this.enableSingleton ?
                { [hook.return]: false }
                : { err: new Error('is connecting or already connected') };
        }
    }
	async [_AFTER_CONNECT](...args) {
        // console.log(`${this.name} 5`);
	    await this.connectedPromise;
        // console.log(`${this.name} 6`);
	    this._changeStatus(transferStatus.CONNECTED, ...args);
    }
    async [_ON_CONNECTED](...args) {
        // console.log(`${this.name} 2`);
	    if (this.connectedPromise.connectedResolve) {
	        // console.log(`${this.name} 3`);
	        this.connectedPromise.connectedResolve();
	        delete this.connectedPromise;
        }
        // console.log(`${this.name} 4`);
	    this._changeStatus(transferStatus.CONNECTED, ...args);
    }

	async [_BEFORE_DISCONNECT](...args) {
		// Crea una promesa incumplida
		if (!this.disconnectedPromise) {
            let disconnectedResolve, disconnectedReject;
            this.disconnectedPromise = new Promise((resolve, reject) => {
                disconnectedResolve = resolve;
                disconnectedReject = reject;
            });
            this.disconnectedPromise.disconnectedResolve = disconnectedResolve;
            this.disconnectedPromise.disconnectedReject = disconnectedReject;
        }
        this._changeStatus(transferStatus.DISCONNECTING, ...args);
    }
	async [_AFTER_DISCONNECT](...args) {
	    // await this.disconnectedPromise;
        this._changeStatus(transferStatus.DISCONNECTED, ...args);
    }
    async [_ON_DISCONNECTED](...args) {
	    if (this.disconnectedPromise.disconnectedResolve) this.disconnectedPromise.disconnectedResolve();
        this._changeStatus(transferStatus.DISCONNECTED, ...args);
    }
	async [_BEFORE_SEND]({ data, options }) {
        // this.assertReady(this.error);
        await this.getReady({ timeout: '2s' });
        let originalData = data;
        try {
            let serializedData = this.serialize(data, { debug: this.debug });
            return { data: serializedData, originalData, options };
        } catch (err) {
	        logger.error(`Error while serializing data before send from transfer <${this.displayName}>: ${err.stack}`);
            return { err };
        }
	}

	[_AFTER_ON_DATA]({ data, context } = {}) {
    	if (data === undefined) return;
    	context = context || {};  // null cannot be auto override
	    try {
	        let deserializedData = this.deserialize(data, { debug: this.debug });
	        if (deserializedData) {
	            if (
	                this.sessionManager
                    && deserializedData.__msgClass__
                    && deserializedData.__msgClass__.sidKey
                ) {
                    let session = this.getSession(deserializedData[this.settings.sidKey]);
                    if (session) {
                        let correspondData = session.data.data;

                        // Utilice responseValidator o responseMessageClass
                        // TODO unificar y mejorar

                        if (correspondData.responseValidator) {
                            if (correspondData.responseValidator(deserializedData))
                                return session.complete({ result: deserializedData });
                        }
                        else {
                            let resMsgClass = correspondData.constructor.responseMessageClass;
                            if (!resMsgClass || resMsgClass === deserializedData.__msgClass__)
                                return session.complete({ result: deserializedData });
                        }
                    }
	            }
                context.transfer = this;
                this.callback(transferEvent.data, { data: deserializedData, context });
	        }
        } catch (err) {
	        logger.error(`Error while deserializing data after received from transfer <${this.displayName}>: ${err.stack}`);
	        return { err };
        }
	}
// —— Gancho privado del transmisor (reservado) ———————————— fin

// —— Conectar/desconectar el transmisor ———————————— comenzar
    /**
     * El método de conexión que implementará la clase heredada
     * @returns {Promise<void>}
     */
    async connect() {

    }
    /**
     * La devolución de llamada conectada que debe registrar la clase heredada
     * Si la clase heredada no admite la conexión en espera, debe registrar esta devolución de llamada
     * @returns {Promise<void>}
     */
    async onConnected() {

    }
    /**
     * Método de desconexión que será implementado por la clase heredada
     * @returns {Promise<void>}
     */
    async disconnect() {

    }
    /**
     * Devolución de llamada desconectada que será registrada por la clase heredada
     * @returns {Promise<void>}
     */
    async onDisconnected() {

    }
    /**
    * El método de reconexión que implementará la clase heredada
     * Se debe implementar al menos uno del método de reconexión y la devolución de llamada de reconexión
     * @returns {Promise<void>}
     */
    async reconnect() {

    }
    /**
    * La devolución de llamada de reconexión que debe registrar la clase heredada
     * Se debe implementar al menos uno del método de reconexión y la devolución de llamada de reconexión
     * @returns {Promise<void>}
     */
    async onReconnecting() {

    }
    async onError(e) {}
// —— Conexión/desconexión del transmisor ———————————— fin

// —— El transmisor envía y recibe ———————————— comienza
    /**
     * El método de envío que implementará la clase heredada
     * @returns {Promise<void>}
     */
    async send({ data, orginalData, options = {} } = {}) {

    }
    /**
     * Enviar en conversación
     * @param timeout
     * @param sid
     * @returns {{send: send}}
     */
    session({ timeout, sid } = {}) {
        if (!this.sessionManager) {
            logger.error(`Error while creating session on transfer <${this.name}>: session manager not initialized`);
        }
	    return {
	        send: (async function ({ data = {}, options = {} } = {}) {
                let session = this.createSession({ timeout, sid: sid || data[this.settings.sidKey] });
	            data[this.settings.sidKey] = session.sid;
	            return await session.toBeComplete({ executor: this.send.bind(this), data: { data, options }  });
            }).bind(this)
        };
    }
    /**
     * El método de recepción que debe registrar la clase heredada
     * @returns {Promise<void>}
     */
    async onData() {
    	return { data: '', context: {} };
    }
// —— El transmisor envía y recibe ———————————— fin

// —— Gestión de sesiones del servicio de mensajes ———————————— comenzar
	/**
	 * Comprueba si el mensaje es una conversación
	 * @param {Object} cuerpo del mensaje
	 * @returns Si el mensaje es una conversación
	 */
	isSession(message) {
		return this.sessionManager.isSession(message);
	}
	/**
	 * Obtener la instancia de sesión del ID de sesión especificado
	 * @param {(String|Number)} sid
	 * @returns La instancia de sesión para el ID de sesión especificado
	 */
	getSession(sid) {
		return this.sessionManager.getSession(sid);
	}
	/**
    * Crear una instancia de sesión
	 * El ID de sesión se asigna automáticamente
	 * @returns instancia de sesión
	 */
	createSession({ timeout, sid } = {}) {
		return this.sessionManager.createSession({ timeout, sid });
	}
// —— Gestión de sesiones del servicio de mensajes ———————————— fin

    /**
     * Función de devolución de llamada de registro de evento
     * @returns {Promise<void>}
     */
    async on(event, callback) {
        // Si la devolución de llamada es una matriz, registre por lotes las devoluciones de llamada al evento
        if (Array.isArray(callback)) {
            for (let cb of callback) {
                await this.on(event, cb);
            }
        }
        // Si la devolución de llamada no está vacía, registre la devolución de llamada en el evento
        else if (callback) {
            if (transferEvent.hasOwnProperty(event) && typeof callback === 'function') {
                this.eventCallbacks[transferEvent[event]].push(callback);
            }
        }
        // Si la devolución de llamada está vacía, el parámetro de evento se considera como un objeto de devolución de llamada de evento por lotes: { ...[evento]: devolución de llamada }
        else {
            for (let _event in event) {
                await this.on(_event, event[_event]);
            }
        }
    }
    /**
     * Función de devolución de llamada del evento de cierre de sesión
     * @returns {Promise<void>}
     */
    async off(event, callback) {
        //Si la devolución de llamada es una matriz, anule el registro por lotes de la devolución de llamada al evento
        if (Array.isArray(callback)) {
            for (let cb of callback) {
                await this.off(event, cb);
            }
        }
        //Si la devolución de llamada no está vacía, anule el registro de la devolución de llamada en el evento
        else if (callback) {
            if (transferEvent.hasOwnProperty(event) && typeof callback === 'function') {
                let callbacks = this.eventCallbacks[transferEvent[event]];
                let index = callbacks.findIndex(cb => cb === callback);
                if (index !== -1) callbacks.splice(index);
            }
        }
        // 若 Si la devolución de llamada está vacía, el parámetro de evento se trata como un objeto de devolución de llamada de evento por lotes: { ...[evento]: devolución de llamada }
        else {
            for (let _event in event) {
                await this.off(_event, event[_event]);
            }
        }
    }
    /**
     *Devolución de llamada de evento de llamada
     * @param event
     * @param args
     * @returns {Promise<void>}
     */
    async callback(event, ...args) {
	    let eventCallbacks = this.eventCallbacks[event];
	    if (eventCallbacks) {
            for (let callback of eventCallbacks) {
                callback(...args);  // El error se lanza directamente
            }
        }
    }
}

TransferBase.transferStatus = transferStatus;

module.exports = {
    TransferBase,
    transferEvent,
	transferStatus,
	transferStatusText,
};
