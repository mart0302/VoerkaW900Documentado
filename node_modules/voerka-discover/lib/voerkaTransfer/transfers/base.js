/*

传输器基类

目的：定义统一接口、封装状态管理、支持注册回调

用法：

// 引入基类、事件名称、状态名称
const { TransferBase, transferEvent, transferStatus } = require('/path/to/transfer/base');

// 实现类
class XXXTransfer extends TransferBase {

    // 实例化函数
    constructor(settings = { name, serializer, deserializer }) {
        // serializer 为序列化器的路径或实例
        // deserializer 为反序列化器的路径或实例
        super(settings);
    }

    // 初始化函数
    async init() {
        // 可在此处编写所需初始化内容
        // 如一些无法在实例化函数中编写的 await 代码
    }

    // 应实现接口如下：

    // 连接方法
    async connect() {
        // 在其中应注册相关回调（见应注册事件回调）
        // 如：client.on('connect', this.onConnected.bind(this));
    }

    // 断开方法
    async disconnect() {

    }

    // 重连方法（可选）
    async reconnect() {

    }

    async send({ data, originalData, options = {} } = {}) {
        // data 为序列化/编码/压缩后的数据（Buffer 或 String），可直接发送
        // originalData 为上述数据的原数据
        // options 为发送选项
    }

    // 应注册回调如下：

    // 已连接回调
    async onConnected() {

    }

    // 已断开回调
    async disconnect() {

    }

    // 已重连回调
    async onDisconnected() {

    }

    // 已出错回调
    async onError(e) {

    }

    // 已接收回调
    async onData() {

    }
}

// 实例化
const xxxTransfer = new XXXTransfer(settings);

// 可在实例上逐个注册事件回调
xxxTransfer.on(event, callback);

// 或在实例上批量注册事件回调
xxxTransfer.on(event, callback);
// 或
xxxTransfer.on(event, [...callbacks]);
// 或
xxxTransfer.on({
    ...[event]: callback
});
// 或
xxxTransfer.on({
    ...[event]: [...callbacks]
});

// 可在实例上逐个或批量注销事件回调（同上，on 改 off）
xxxTransfer.on(event, [callback]);

注：事件名称 event 从 transferEvent 中取得
有：
- transferEvent.connected
- transferEvent.disconnected
- transferEvent.data
- transferEvent.error

// 可等待传输器准备就绪（即已连接）
await xxxTransfer.getReady(timeout).catch(e => {});  // true

// 或检查传输器状态
xxxTransfer.isStatus(transferStatus[status]);  // true or false
// 如：检查是否已连接（不是等待）
xxxTransfer.isStatus(transferStatus.CONNECTED);

 */

const ms = require('ms');
const assert = require('assert');
const { hook } = require('../utils/functools');
const { flexibleRequire } = require('../utils/requireutils');
const { SessionManager } = require('../utils/session');

// 传输器状态值
const transferStatus = {
	INITIALIZING : Symbol('INITIALIZING'),  // 初始化中
	INITIALIZED  : Symbol('INITIALIZED'),   // 已初始化
	CONNECTING   : Symbol('CONNECTING'),    // 连接中
	CONNECTED    : Symbol('CONNECTED'),     // 已连接（运行中）
	RECONNECTING : Symbol('RECONNECTING'),  // 重连中
	DISCONNECTING: Symbol('DISCONNECTING'), // 断开中
	DISCONNECTED : Symbol('DISCONNECTED'),  // 已断开
	ERROR        : Symbol('ERROR'),         // 发生错误
};

const transferEvent = {
    connected   : 'connected',
    disconnected: 'disconnected',
    data        : 'data',
    error       : 'error',
};

// 传输器状态文本
const transferStatusText = {
	[transferStatus.INITIALIZING] : 'initializing',              // 初始化中
	[transferStatus.INITIALIZED]  : 'initialized',               // 已初始化
	[transferStatus.CONNECTING]   : 'connecting',                // 连接中
	[transferStatus.CONNECTED]    : transferEvent.connected,     // 已连接（运行中）
	[transferStatus.RECONNECTING] : 'connecting',                // 重连中
	[transferStatus.DISCONNECTING]: 'disconnecting',             // 断开中
	[transferStatus.DISCONNECTED] : transferEvent.disconnected,  // 已断开
	[transferStatus.ERROR]        : transferEvent.error,         // 发生错误
};

const _BEFORE_INIT = Symbol('_beforeInit');  // before call init
const _AFTER_INIT = Symbol('_afterInit');  // after all init while before real init
const _ON_INIT = Symbol('_onInit');  // after real init
const _BEFORE_CONNECT = Symbol('_beforeConnect');
const _AFTER_CONNECT = Symbol('_afterConnect');
const _ON_CONNECTED = Symbol('_onConnected');
const _BEFORE_DISCONNECT = Symbol('_beforeDisconnect');
const _AFTER_DISCONNECT = Symbol('_afterDisconnect');
const _ON_DISCONNECTED = Symbol('_onDisconnected');
const _BEFORE_RECONNECT = Symbol('_beforeReconnect');
const _BEFORE_SEND = Symbol('_beforeSend');
const _AFTER_ON_DATA = Symbol('_afterOnData');  // equals to _ON_DATA

// 保护单例不被篡改
const _SINGLETON = Symbol('_singleton');

const TIMEOUT_FLAG = Symbol('TIMEOUT_FLAG');

const idle = (x) => x;
global.logger = global.logger || {
    info: (...args) => console.info('[INFO]', ...args),
    debug: (...args) => console.debug('[DEBUG]', ...args),
    warn: (...args) => console.warn('[WARN]', ...args),
    error: (...args) => console.error('[ERROR]', ...args),
};

// 传输器基类
class TransferBase {
// —— 传输器初始化 ———————————— begin
	/**
	 * 
	 * @param {Object} settings 传输器配置
	 */
	constructor(settings, sessionManager) {
	    // 支持单例
        this.enableSingleton = this.constructor.enableSingleton;
        // 如果 enableSingleton 返回 true，则使用默认保存的单例，否则如果不为假值（false、undefined、''）就返回其调用结果作为单例
        let isSingleTon = typeof this.enableSingleton === 'function' ? this.enableSingleton(this, ...arguments) : this.enableSingleton;
        if (isSingleTon === true) {
            if (this.constructor[_SINGLETON]) return Object.assign(this, this.constructor[_SINGLETON]);
            this.constructor[_SINGLETON] = this;
        }
        else if (isSingleTon) {
            return Object.assign(this, isSingleTon);
        }

        // 错误
        this.error = null;

		// 配置
		this.settings = Object.assign({}, this.constructor.__proto__.prototype.defaultSettings(), this.defaultSettings(), settings);
		if (sessionManager) this.sessionManager = sessionManager;
		else {
			this.sessionManager = new SessionManager(this.settings.session);
			this.sessionManager.start();
		}
		// if (!sessionManager) logger.debug(`Transfer <${this.name}> session manager not initialized`);

		// 客户端
		this.endpoint = null;
		this.connectedPromise = {};
		this.disconnectedPromise = {};

		// 事件回调函数列表
        this.eventCallbacks = {
            [transferEvent.connected]: [],
            [transferEvent.disconnected]: [],
            [transferEvent.data]: [],
            [transferEvent.error]: [],
        };

        // 为必要的函数装饰（启用）状态管理能力
        // 注：状态管理能力包括：状态变更和状态条件检查
        // 状态条件检查如：在已连接状态下不能重复连接（而应该调用重启方法）
		this._enableManageStatus();

		this._changeStatus(transferStatus.INITIALIZING);
		// 序列化
        let { serializer, deserializer } = this.settings;
        try {
            this.serialize = serializer ?
                (typeof serializer === 'string' ? flexibleRequire(serializer) : serializer)
                : idle;
        } catch (e) {
            logger.error(`Error while importing serializer for Transfer <${this.displayName}>: ${e.stack}`);
            this._changeStatus(transferStatus.ERROR);
        }
        try {
            this.deserialize = deserializer ?
                (typeof deserializer === 'string' ? flexibleRequire(deserializer) : deserializer)
                : idle;
        } catch (e) {
            logger.error(`Error while importing deserializer for Transfer <${this.displayName}>: ${e.stack}`);
            this._changeStatus(transferStatus.ERROR);
        }
        this._changeStatus(transferStatus.INITIALIZED);
	}
	/**
	 * 初始化函数
	 * 可由继承类实现
	 */
	async init() {

    }
    /**
     * 默认设置
     * @returns {{name: string, sidKey: string}}
     */
    defaultSettings() {
	    return {
            name: this.constructor.name,
            sidKey: 'sid'
        };
    }
// —— 传输器初始化 ———————————— end

// —— 传输器属性 ———————————— begin
	get name() {
		return this.settings.name || this.constructor.name;
	}
	get debug() {
		return this.settings.debug;
	}
	get displayName() {
		return this.settings.name || this.constructor.name;
	}
// —— 传输器属性 ———————————— end

// —— 传输器运行状态 ———————————— begin
	/**
	 * 使能模块运行状态管理
	 * 包括：状态变更和状态条件检查
	 * 如：在已启动状态下不能重复启动（而应该调用重启方法）
	 * （此方法以被抽象为 hook）
	 */
	_enableManageStatus() {
		let onError = e => { this._changeStatus(transferStatus.ERROR, e); };
		hook(this, [
			{
				before: this[_BEFORE_INIT],
				original: this.init,
				after: this[_AFTER_INIT],
				error: onError
			},
			{
				before: this[_BEFORE_CONNECT],
				original: this.connect,
				after: this[_AFTER_CONNECT],
				error: onError
			},
			{
				before: this[_BEFORE_DISCONNECT],
				original: this.disconnect,
				after: this[_AFTER_DISCONNECT],
				error: onError
			},
			{
				before: this[_BEFORE_CONNECT],
				original: this.reconnect,
				after: this[_AFTER_CONNECT],
				error: onError
			},
			{
				before: this[_BEFORE_SEND],
				original: this.send
			},
			{
				original: this.onData,
				after: this[_AFTER_ON_DATA]
			},
			{
				original: this.onConnected,
				after: this[_ON_CONNECTED]
			},
			{
				original: this.onDisconnected,
				after: this[_ON_DISCONNECTED]
			},
			{
				original: this.onReconnecting,
				after: this[_BEFORE_CONNECT]
			},
		]);
	}
	/**
	 * 变更模块状态
	 * @param {Number} status
	 */
	_changeStatus(status, ...args) {
	    // 状态无变化，不重复处理
        if (this.isStatus(status)) return;

	    // 上一个状态
        let prevStatus = this.status;
		// 变更状态
		this.status = status;

        // 如果是 error 是错误对象，还应设置错误
        // 如果已经是 Error 实例，则无需重复实例化
        if (status === transferStatus.ERROR) {
            this.error = args[0] instanceof Error ? args[0] : new Error(args[0]);
            // 记录日志
            logger.error(`Error while ${transferStatusText[prevStatus]} transfer <${this.displayName}>: ${this.error.stack}`);
            // 如果正在连接或断开，还应结束相关的 promise
            if (prevStatus === transferStatus.CONNECTING && this.connectedPromise) this.connectedPromise.connectedReject(this.error);
            if (prevStatus === transferStatus.DISCONNECTING && this.disconnectedPromise) this.disconnectedPromise.disconnectedReject(this.error);
        }

		// 记录日志
		if (this.error) {
			logger.info(`Transfer <${this.displayName}> is ${transferStatusText[status]}: ${this.error.stack}`);
		}
		else {
		    logger.info(`Transfer <${this.displayName}> is ${transferStatusText[status]}`);
        }

		// 触发回调
		this.onChangeStatus(status, ...args);
	}

	/**
	 * 判断当前状态
	 * @param {Symbol} status
	 */
	isStatus(status) {
		return this.status === status;
	}
    /**
	 * 状态变更后调用
     * @param {Symbol} status 状态码
     */
	onChangeStatus(status, ...args) {
	    this.callback(transferStatusText[status], ...args);
    }

	/**
	 * 模块就绪状态
	 * 依赖该模块时，应自行检查
	 */
	get isReady() {
		return this.isStatus(transferStatus.CONNECTED);
	}
    /**
     * 确认模块就绪
     * @param message
     */
    assertReady(message) {
        assert(this.isReady, message || `Transfer <${this.displayName}> not ready`);
    }
    /**
     * 等待模块就绪
     * @returns {Promise<void>}
     */
    async getReady({ timeout } = {}) {
        if (timeout) {
            let result = await Promise.race([
                this.connectedPromise,
                new Promise(resolve => setTimeout(() => resolve(TIMEOUT_FLAG), ms(timeout)))
            ]);
            if (result === TIMEOUT_FLAG) this.assertReady(this.error);
        }
        else await this.connectedPromise;
	}

// —— 传输器运行状态 ———————————— end

// —— 传输器私有钩子（预留） ———————————— begin
	async [_BEFORE_INIT](...args) {
        this._changeStatus(transferStatus.INITIALIZING, ...args);
    }
	async [_AFTER_INIT](...args) {
        // 初始化完毕后，变更状态为“初始化完毕”
        this._changeStatus(transferStatus.INITIALIZED, ...args);
    }

	async [_BEFORE_CONNECT](...args) {
        // console.log(`[MEOW] Transfer ${this.displayName}(${transferStatusText[this.status]}) is trying to connect`);
	    // 只有状态在 已初始化 或 已断开 或 错误 时才能连接
	    if (this.isStatus(transferStatus.INITIALIZED) || this.isStatus(transferStatus.DISCONNECTED) || this.isStatus(transferStatus.ERROR)) {
	        // 当前状态为初始化完毕，则状态切换为连接中，否则都是重连中
            this.isStatus(transferStatus.INITIALIZED) ?
                this._changeStatus(transferStatus.CONNECTING, ...args)
                : this._changeStatus(transferStatus.RECONNECTING, ...args);
            // 兼容不支持 await 的连接
            // 创建连接 promise
            if (!this.connectedPromise) {
                let connectedResolve, connectedReject;
                this.connectedPromise = new Promise((resolve, reject) => {
                    connectedResolve = resolve;
                    connectedReject = reject;
                });
                this.connectedPromise.connectedResolve = connectedResolve;
                this.connectedPromise.connectedReject = connectedReject;
            }
        }
        else {
	        // console.log(`[MEOW] Transfer ${this.displayName}(${transferStatusText[this.status]}) cannot connect`);
	        // 其它状况可能是 连接中 或 已连接
            // 单例情况下，重复连接不会报错，直接忽略
	        return this.enableSingleton ?
                { [hook.return]: false }
                : { err: new Error('is connecting or already connected') };
        }
    }
	async [_AFTER_CONNECT](...args) {
        // console.log(`${this.name} 5`);
	    await this.connectedPromise;
        // console.log(`${this.name} 6`);
	    this._changeStatus(transferStatus.CONNECTED, ...args);
    }
    async [_ON_CONNECTED](...args) {
        // console.log(`${this.name} 2`);
	    if (this.connectedPromise.connectedResolve) {
	        // console.log(`${this.name} 3`);
	        this.connectedPromise.connectedResolve();
	        delete this.connectedPromise;
        }
        // console.log(`${this.name} 4`);
	    this._changeStatus(transferStatus.CONNECTED, ...args);
    }

	async [_BEFORE_DISCONNECT](...args) {
		// 创建断开 promise
		if (!this.disconnectedPromise) {
            let disconnectedResolve, disconnectedReject;
            this.disconnectedPromise = new Promise((resolve, reject) => {
                disconnectedResolve = resolve;
                disconnectedReject = reject;
            });
            this.disconnectedPromise.disconnectedResolve = disconnectedResolve;
            this.disconnectedPromise.disconnectedReject = disconnectedReject;
        }
        this._changeStatus(transferStatus.DISCONNECTING, ...args);
    }
	async [_AFTER_DISCONNECT](...args) {
	    // await this.disconnectedPromise;
        this._changeStatus(transferStatus.DISCONNECTED, ...args);
    }
    async [_ON_DISCONNECTED](...args) {
	    if (this.disconnectedPromise.disconnectedResolve) this.disconnectedPromise.disconnectedResolve();
        this._changeStatus(transferStatus.DISCONNECTED, ...args);
    }
	async [_BEFORE_SEND]({ data, options }) {
        // this.assertReady(this.error);
        await this.getReady({ timeout: '2s' });
        let originalData = data;
        try {
            let serializedData = this.serialize(data, { debug: this.debug });
            return { data: serializedData, originalData, options };
        } catch (err) {
	        logger.error(`Error while serializing data before send from transfer <${this.displayName}>: ${err.stack}`);
            return { err };
        }
	}

	[_AFTER_ON_DATA]({ data, context } = {}) {
    	if (data === undefined) return;
    	context = context || {};  // null cannot be auto override
	    try {
	        let deserializedData = this.deserialize(data, { debug: this.debug });
	        if (deserializedData) {
	            if (
	                this.sessionManager
                    && deserializedData.__msgClass__
                    && deserializedData.__msgClass__.sidKey
                ) {
                    let session = this.getSession(deserializedData[this.settings.sidKey]);
                    if (session) {
                        let correspondData = session.data.data;

                        // 使用 responseValidator 或 responseMessageClass
                        // TODO 统一并完善

                        if (correspondData.responseValidator) {
                            if (correspondData.responseValidator(deserializedData))
                                return session.complete({ result: deserializedData });
                        }
                        else {
                            let resMsgClass = correspondData.constructor.responseMessageClass;
                            if (!resMsgClass || resMsgClass === deserializedData.__msgClass__)
                                return session.complete({ result: deserializedData });
                        }
                    }
	            }
                context.transfer = this;
                this.callback(transferEvent.data, { data: deserializedData, context });
	        }
        } catch (err) {
	        logger.error(`Error while deserializing data after received from transfer <${this.displayName}>: ${err.stack}`);
	        return { err };
        }
	}
// —— 传输器私有钩子（预留） ———————————— end

// —— 传输器连接/断开 ———————————— begin
    /**
     * 继承类要实现的连接方法
     * @returns {Promise<void>}
     */
    async connect() {

    }
    /**
     * 继承类要注册的已连接回调
     * 如果继承类不支持 await 连接，则必须注册该回调
     * @returns {Promise<void>}
     */
    async onConnected() {

    }
    /**
     * 继承类要实现的断开方法
     * @returns {Promise<void>}
     */
    async disconnect() {

    }
    /**
     * 继承类要注册的已断开回调
     * @returns {Promise<void>}
     */
    async onDisconnected() {

    }
    /**
     * 继承类要实现的重连方法
     * 重连方法和重连中回调要至少实现其中一个
     * @returns {Promise<void>}
     */
    async reconnect() {

    }
    /**
     * 继承类要注册的重连中回调
     * 重连方法和重连中回调至少要实现其中一个
     * @returns {Promise<void>}
     */
    async onReconnecting() {

    }
    async onError(e) {}
// —— 传输器连接/断开 ———————————— end

// —— 传输器发送和接收 ———————————— begin
    /**
     * 继承类要实现的发送方法
     * @returns {Promise<void>}
     */
    async send({ data, orginalData, options = {} } = {}) {

    }
    /**
     * 在会话中发送
     * @param timeout
     * @param sid
     * @returns {{send: send}}
     */
    session({ timeout, sid } = {}) {
        if (!this.sessionManager) {
            logger.error(`Error while creating session on transfer <${this.name}>: session manager not initialized`);
        }
	    return {
	        send: (async function ({ data = {}, options = {} } = {}) {
                let session = this.createSession({ timeout, sid: sid || data[this.settings.sidKey] });
	            data[this.settings.sidKey] = session.sid;
	            return await session.toBeComplete({ executor: this.send.bind(this), data: { data, options }  });
            }).bind(this)
        };
    }
    /**
     * 继承类要注册的接收方法
     * @returns {Promise<void>}
     */
    async onData() {
    	return { data: '', context: {} };
    }
// —— 传输器发送和接收 ———————————— end

// —— 消息服务会话管理 ———————————— begin
	/**
	 * 检查消息是否为会话
	 * @param {Object} message 消息体
	 * @returns 消息是否为会话
	 */
	isSession(message) {
		return this.sessionManager.isSession(message);
	}
	/**
	 * 获取指定会话 id 的会话实例
	 * @param {(String|Number)} sid
	 * @returns 指定会话 id 的会话实例
	 */
	getSession(sid) {
		return this.sessionManager.getSession(sid);
	}
	/**
	 * 创建会话实例
	 * 会话 id 自动分配
	 * @returns 会话实例
	 */
	createSession({ timeout, sid } = {}) {
		return this.sessionManager.createSession({ timeout, sid });
	}
// —— 消息服务会话管理 ———————————— end

    /**
     * 注册事件回调函数
     * @returns {Promise<void>}
     */
    async on(event, callback) {
        // 若 callback 为数组则批量注册该回调到该事件
        if (Array.isArray(callback)) {
            for (let cb of callback) {
                await this.on(event, cb);
            }
        }
        // 若 callback 不为空，则注册该回调到该事件
        else if (callback) {
            if (transferEvent.hasOwnProperty(event) && typeof callback === 'function') {
                this.eventCallbacks[transferEvent[event]].push(callback);
            }
        }
        // 若 callback 为空，则视 event 参数为批量事件-回调对象： { ...[event]: callback }
        else {
            for (let _event in event) {
                await this.on(_event, event[_event]);
            }
        }
    }
    /**
     * 注销事件回调函数
     * @returns {Promise<void>}
     */
    async off(event, callback) {
        // 若 callback 为数组则批量注销该回调到该事件
        if (Array.isArray(callback)) {
            for (let cb of callback) {
                await this.off(event, cb);
            }
        }
        // 若 callback 不为空，则注销该回调到该事件
        else if (callback) {
            if (transferEvent.hasOwnProperty(event) && typeof callback === 'function') {
                let callbacks = this.eventCallbacks[transferEvent[event]];
                let index = callbacks.findIndex(cb => cb === callback);
                if (index !== -1) callbacks.splice(index);
            }
        }
        // 若 callback 为空，则视 event 参数为批量事件-回调对象： { ...[event]: callback }
        else {
            for (let _event in event) {
                await this.off(_event, event[_event]);
            }
        }
    }
    /**
     * 调用事件回调
     * @param event
     * @param args
     * @returns {Promise<void>}
     */
    async callback(event, ...args) {
	    let eventCallbacks = this.eventCallbacks[event];
	    if (eventCallbacks) {
            for (let callback of eventCallbacks) {
                callback(...args);  // 错误直接抛出
            }
        }
    }
}

TransferBase.transferStatus = transferStatus;

module.exports = {
    TransferBase,
    transferEvent,
	transferStatus,
	transferStatusText,
};
