/*

	MQTT传输器基类

*/

// 内置或外部工具
const path = require('path');
const uuidv4 = require('uuid/v4');
const pluralize = require('pluralize');
const { promisify } = require('util');

// mqtt & store
const mqtt = require('mqtt');

// 传输器基类
const { TransferBase } = require('./base');

const _ON_CONNECTED = Symbol('_onConnected');
const _ON_DISCONNECTED = Symbol('_onDisconnected');

class MQTTTransfer extends TransferBase {
// —— mqtt传输器初始化 ———————————— begin
	constructor(settings) {
		super(settings);
		let willPayload = (settings.will || {}).payload;
		if (willPayload && (typeof willPayload !== 'string'|| !Buffer.isBuffer(willPayload))) {
			settings.will.payload = this.serialize(willPayload, { debug: settings.willDebug });
		}
		this.subscribedTopics = {};
	}
// —— mqtt传输器初始化 ———————————— end
	
// —— mqtt传输器属性 ———————————— begin
	get displayName() {
		return `MQTT Transfer <${this.name}> [Client ${this.clientId} -> ${this.broker}]`;
	}
	get broker() {
		return this.settings.broker;
	}
	get clientId() {
		if (!this._clientId) this._clientId = this.settings.id || uuidv4();
		return this._clientId;
	}
// —— mqtt传输器属性 ———————————— end

// —— mqtt传输器连接和断开 ———————————— begin
	/**
	 * 连接
	 */
	async connect() {
		// 构建 mqtt 客户端连接选项
		let options = {
			// clientId 格式为 'voerka_{设备类型}_{设备序列号}'
			clientId: this.clientId,

			// WebSocket 连接选项 详见 https://github.com/websockets/ws/blob/master/doc/ws.md
			wsOptions: {},

			// 保活间隔(秒) 0=不启用
			keepalive: 60, 

			// 是否在发送信息之后再发送 ping-request
			// 注: 
			//   当设置保活间隔时, 客户端每隔设定时间内就会发送 ping 消息给 broker
			//   reschedule pings 就是说, 要不要在发送了一条任意消息之后, 再发送一个 ping 消息给 broker
			//   猜测: 这取决于 broker 的设置, 如果 broker 愿意以任意消息当做 ping request, 则可设置为 false
			// 参:
			//   - [mqtt 要点(第三篇) 其中 Keep-Alive 部分](https://www.hivemq.com/blog/mqtt-essentials-part-3-client-broker-connection-establishment/)
			//   - [mqtt 要点(第十篇) 全部](https://www.hivemq.com/blog/mqtt-essentials-part-10-alive-client-take-over/)
			reschedulePings: true,

			// 协议名称
			protocolId: 'MQTT',

			// 协议版本
			protocolVersion: 4,

			// 是否使用 cleanSession
			// 注:
			//   cleanSession 与 persistSession 相对应
			//   cleanSession 设置为 false 则 persistSession 为 true, 
			//   此时 broker 会为该客户端保存会话, 以便在客户端断线重连之后, 
			//   不必重新订阅主题, 并且可以获得离线时为它缓存的它所订阅的 qos=1和2 的消息
			//   cleanSession 设置为 true 则无上述功能
			// 参:
			//   - [mqtt 要点(第七篇)](https://www.hivemq.com/blog/mqtt-essentials-part-7-persistent-session-queuing-messages/)
			clean: true,

			// 重连间隔(毫秒) 两次重连之间的时间间隔, 也就是重连的频繁程度
			reconnectPeriod: 10000, 

			// 连接超时时间(毫秒)
			connectTimeout: 30 * 1000,
			
			// 用户名(默认无)
			username: null,

			// 密码(默认无)
			password: null,

			// 订阅消息存储
			// 注:
			//   用于 qos=2 的消息存储
			//   因为 qos=2 的消息在接收后, 
			//     发出 PUBACK(向 broker 确认消息已经送达本客户端) 后, 
			//       还需要等待收到 PUBREL(确认 broker 已经收到 PUBACK) 后, 
			//         再发出 PUBCOMP
			//   所以在收到这些消息之后, 客户端仍然要存储这些消息, 以等待确认消息后处理, 超时则重发 PUBACK
			//   默认不指定消息存储时, 则使用内存, 指定存储时可持久化保存(重启不影响)
			// 参:
			//   - [What is the purpose of using stores?](https://github.com/mqttjs/MQTT.js/issues/676)
			//   - [mqtt 要点(第六篇)](https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/)
			incomingStore: null, 

			// 发布消息存储
			// 注:
			//   用于 qos=1 和 qos=2 的消息存储
			//   因为 qos=1 和 qos=2 的消息在发出后需要获得 broker 的确认(PUBACK)消息(确认消息已经送达 broker)
			//   所以在发送这些消息之后, 客户端仍然要存储这些消息, 以等待确认消息后处理, 超时则重发该消息
			//   默认不指定消息存储时, 则使用内存, 指定存储时可持久化保存(重启不影响)
			// 参:
			//   - [What is the purpose of using stores?](https://github.com/mqttjs/MQTT.js/issues/676)
			//   - [mqtt 要点(第六篇)](https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/)
			outgoingStore: null,

			// 连接断开时, 是否将未发出的 qos=0 的消息放入队列
			// 也就是说, 断开连接时是否保存 qos=0 的消息使其在重连后得到发送(false=不保存/不放入队列)
			// 需知: mqtt.js 不论 qos=any 都会默认把消息放入队列
			// 参考: [Connection is broken query](https://github.com/mqttjs/MQTT.js/issues/431)
			queueQoSZero: true,

			// 其它选项见 https://github.com/mqttjs/MQTT.js#connect
			// customHandleAcks: 库默认,
			// properties: 库默认,
			// authPacket: 库默认,
			// will: 库默认,
			// transformWsUrl: 库默认,
			// resubscribe： 库默认
		};

		Object.assign(options, this.settings);

		// 如果没有指定则使用内存

		// 创建 mqtt 消息收发终端
		this.endpoint = mqtt.connect(this.broker, options);
		this.endpoint.on('connect', this[_ON_CONNECTED].bind(this));  // 已连接
		this.endpoint.on('close', async () => {
			await this.onDisconnected();
			this.endpoint.removeAllListeners();
			await new Promise(resolve => this.endpoint.end(true, resolve));
			await this.connect();
		});  // 已断开（断开需要强制关闭连接再重连，否则重新订阅会无效）
		this.endpoint.on('error', this.onError.bind(this));  // 已错误
		this.endpoint.on('reconnect', this.onReconnecting.bind(this));  // 重连中
		this.endpoint.on('message', this.onData.bind(this));  // 收到数据
	}
	/**
	 * 断开
	 */
	async disconnect() {
		// 清理监听器, 断开连接，销毁客户端
	    let subscribedTopics = this.subscribedTopics;
	    for (let topic in subscribedTopics) {
	    	try {
	    		await this.unsubscribe(topic);
			} catch (e) {  // 出错不影响其它订阅
                (logger && logger.error.bind(logger) || console.error)(`Error unsubscribing topic <${topic}>: ${e.stack}`);
            }
        }
		this.endpoint.removeAllListeners();
		await new Promise(resolve => this.endpoint.end(true, resolve));
		this.endpoint = null;
	}
	/**
	* 重连
	*/
	async reconnect() {
		this.endpoint.reconnect();
	}
// —— mqtt传输器连接和断开 ———————————— end

// —— mqtt传输器私有钩子（预留） ———————————— begin
	/**
	 * 已连接回调(私有)
	 */
	async [_ON_CONNECTED]() {
	    // 留码查看：连接后订阅已订阅的主题，因为断开后可能不会自动订阅
	    // let subscribedTopics = this.subscribedTopics;
	    // for (let topic in subscribedTopics) {
	    // 	try {
	    // 		await this.subscribe(topic, subscribedTopics[topic].options);
		// 	} catch (e) {  // 出错不影响其它订阅
        //         (logger && logger.error || console.error)(`Error subscribing topic <${topic}>: ${e.stack}`);
        //     }
        // }
        await this.onConnected();
	}
	/**
	 * 已断开回调(私有)
	 */
	async [_ON_DISCONNECTED]() {

	}
// —— mqtt传输器私有钩子（预留） ———————————— end

// —— mqtt传输器钩子 ———————————— begin
	/**
	 * 已连接回调
	 */
	onConnected() {

    }
	/**
	 * 已断开
	 */
	onDisconnected() {

    }
	/**
	 * 已错误
	 * @param {Object} e 错误实例
	 */
	onError(e) {}

    /**
     * 已收到
     * @param topic
     * @param data
     * @param packet
     * @returns {{data: *, context: {topic: *, packet: *}}}
     */
    onData(topic, data, packet) {
        return { data, context: { topic, packet } };
    }
// —— mqtt传输器钩子 ———————————— end

// —— mqtt传输器发送和接收 ———————————— begin
    /**
     * 发送
     */
	async send({ data: message, originalData: _message, options = {} } = {}) {
        if (options.topic) await this.publish(options.topic, message, options);
    }
	async subscribe(topic, options = {}, callback) {
		options.qos = 2;  // TODO temp code
		// 注： promisify 直接使用的话要求第二参数必须是 callback，而这里是 options
		let { err, granted } = await new Promise(resolve => {
		    this.endpoint.subscribe(topic, (err, granted) => {
		        resolve({ err, granted })
            });
        });
        // granted is an array of {topic, qos} where:
        // 	topic is a subscribed to topic
        // 	qos is the granted qos level on it
        // granted.forEach(g => {
        // 	this.subscribedTopics[g.topic] = g;
        // });
        granted.forEach(g => { this.subscribedTopics[g.topic] = { topic: g.topic, options }; });
        if (typeof callback === 'function') callback(err, granted);
	}
	async unsubscribe(topic, callback) {
		// 注： promisify 直接使用的话要求第二参数必须是 callback，而这里是 options
		// 注： mqtt 客户端需在已连接状态下进行退订才不会阻塞
		let { err } = this.endpoint.connected && await new Promise(resolve => {
			this.endpoint.unsubscribe(topic, err => {
				resolve({ err })
			});
		}) || {};
        // granted is an array of {topic, qos} where:
        // 	topic is a subscribed to topic
        // 	qos is the granted qos level on it
        let topicObj = (typeof topic === 'string') ? [topic] : topic;
        let topics = Array.isArray(topicObj) ? topicObj : Object.keys(topicObj);
        topics.forEach(topic => {
            delete this.subscribedTopics[topic];
        });
        if (typeof callback === 'function') callback(err);
	}
	async publish(topic, message, options = {}, callback) {
		options.qos = 2;  // TODO temp code
		await promisify(this.endpoint.publish).call(this.endpoint, topic, message, options);
        if (typeof callback === 'function') callback();
	}
// —— mqtt传输器发送和接收 ———————————— end
}

module.exports = MQTTTransfer;
