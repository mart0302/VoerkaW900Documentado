/*

	Clase base de transporte MQTT

*/

// Herramientas integradas o externas
const path = require('path');
const uuidv4 = require('uuid/v4');
const pluralize = require('pluralize');
const { promisify } = require('util');

// mqtt & store
const mqtt = require('mqtt');

//Clase base del transmisor
const { TransferBase } = require('./base');

const _ON_CONNECTED = Symbol('_onConnected');
const _ON_DISCONNECTED = Symbol('_onDisconnected');

class MQTTTransfer extends TransferBase {
// —— inicialización del transporte mqtt ———————————— comenzar
	constructor(settings) {
		super(settings);
		let willPayload = (settings.will || {}).payload;
		if (willPayload && (typeof willPayload !== 'string'|| !Buffer.isBuffer(willPayload))) {
			settings.will.payload = this.serialize(willPayload, { debug: settings.willDebug });
		}
		this.subscribedTopics = {};
	}
// —— inicialización del transporte mqtt ———————————— fin
	
// —— propiedades de transporte mqtt ———————————— comenzar
	get displayName() {
		return `MQTT Transfer <${this.name}> [Client ${this.clientId} -> ${this.broker}]`;
	}
	get broker() {
		return this.settings.broker;
	}
	get clientId() {
		if (!this._clientId) this._clientId = this.settings.id || uuidv4();
		return this._clientId;
	}
// —— propiedades de transporte mqtt ———————————— fin

// —— Conexión y desconexión del transporte mqtt ———————————— comienza
	/**
	 * conectar
	 */
	async connect() {
		// Construir opciones de conexión del cliente mqtt
		let options = {
			// El formato del clientId es 'voerka_{tipo de dispositivo}_{número de serie del dispositivo}'
			clientId: this.clientId,

			// Opciones de conexión WebSocket Consulte https://github.com/websockets/ws/blob/master/doc/ws.md para obtener más detalles
			wsOptions: {},

			// Intervalo de mantenimiento (segundos) 0 = Deshabilitar
			keepalive: 60, 

			// Si se debe enviar una solicitud de ping después de enviar un mensaje
			// Nota: 
			// Cuando se establece el intervalo de mantenimiento de conexión, el cliente enviará un mensaje de ping al bróker cada vez que se establezca
			// reprogramar pings significa si se debe enviar un mensaje de ping al broker después de enviar cualquier mensaje
			// Adivinanza: esto depende de la configuración del bróker. Si el broker está dispuesto a tratar cualquier mensaje como una solicitud de ping, se puede configurar como falso.
			// Parámetros:
			// - [Fundamentos de MQTT (Parte 3) Parte Keep-Alive](https://www.hivemq.com/blog/mqtt-essentials-part-3-client-broker-connection-establishment/)
			// - [Fundamentos de MQTT (Parte 10) Todos](https://www.hivemq.com/blog/mqtt-essentials-part-10-alive-client-take-over/)
			reschedulePings: true,

			//Nombre del protocolo
			protocolId: 'MQTT',

			//Versión del protocolo
			protocolVersion: 4,

			// Si se debe utilizar cleanSession
			// Nota:
			//cleanSession corresponde a persistSession
			// Si cleanSession se establece como falso, persistSession es verdadero.
			// En este momento, el broker guardará la sesión para el cliente de modo que después de que el cliente se desconecte y vuelva a conectarse,
			// No es necesario volver a suscribirse al tema, y ​​puede obtener los mensajes de qos=1 y 2 a los que se suscribió en caché cuando está fuera de línea
			// Si cleanSession se establece como verdadero, las funciones anteriores no funcionarán
			// Parámetros:
			// - [Fundamentos de MQTT (Parte 7)](https://www.hivemq.com/blog/mqtt-essentials-part-7-persistent-session-queuing-messages/)
			clean: true,

			// Intervalo de reconexión (milisegundos) El intervalo de tiempo entre dos reconexiones, es decir, la frecuencia de reconexión
			reconnectPeriod: 10000, 

			// Tiempo de espera de conexión (milisegundos)
			connectTimeout: 30 * 1000,
			
			// Nombre de usuario (ninguno por defecto)
			username: null,

			// Contraseña (predeterminada: ninguna)
			password: null,

			// Almacenamiento de mensajes de suscripción
			// Nota:
			// Almacenamiento de mensajes para qos=2
			//Porque se recibe el mensaje con qos=2,
			// Después de enviar PUBACK (confirmando al broker que el mensaje ha sido entregado al cliente),
			// Aún es necesario esperar a recibir PUBREL (confirmando que el broker ha recibido PUBACK),
			// Emite PUBCOMP nuevamente
			// Entonces, después de recibir estos mensajes, el cliente aún necesita almacenarlos para esperar a que se procesen los mensajes de confirmación y volver a enviar PUBACK si expira el tiempo de espera.
			// Si el almacenamiento del mensaje no se especifica de forma predeterminada, se utiliza la memoria. Si se especifica el almacenamiento, se puede conservar (no se ve afectado por el reinicio)
			// Parámetros:
			// - [¿Cuál es el propósito de usar tiendas?](https://github.com/mqttjs/MQTT.js/issues/676)
			// - [Fundamentos de MQTT (Parte 6)](https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/)
			incomingStore: null, 

			// Publicar almacenamiento de mensajes
			// Nota:
			// Almacenamiento de mensajes para qos=1 y qos=2
			// Porque los mensajes qos=1 y qos=2 necesitan recibir el mensaje de confirmación del broker (PUBACK) después de ser enviados (confirmando que el mensaje ha sido entregado al broker)
			// Entonces, después de enviar estos mensajes, el cliente aún necesita almacenarlos para esperar la confirmación y luego procesarlos. Si expira el tiempo de espera, el mensaje se volverá a enviar.
			// Si el almacenamiento del mensaje no se especifica de forma predeterminada, se utiliza la memoria. Si se especifica el almacenamiento, se puede conservar (no se ve afectado por el reinicio)
			// Parámetros:
			// - [¿Cuál es el propósito de usar tiendas?](https://github.com/mqttjs/MQTT.js/issues/676)
			// - [Fundamentos de MQTT (Parte 6)](https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/)
			outgoingStore: nulo,
			outgoingStore: null,

			// Cuando se desconecta la conexión, si se deben colocar los mensajes qos=0 no enviados en la cola
			// En otras palabras, si se deben guardar los mensajes qos=0 cuando se está desconectado para que puedan enviarse después de la reconexión (falso=no guardar/no poner en cola)
			// Nota: mqtt.js pondrá los mensajes en la cola de forma predeterminada independientemente de qos=any
			// Referencia: [Consulta de conexión interrumpida](https://github.com/mqttjs/MQTT.js/issues/431)
			queueQoSZero: verdadero,

			// Para otras opciones, consulte https://github.com/mqttjs/MQTT.js#connect
			// customHandleAcks: valor predeterminado de la biblioteca,
			// propiedades: biblioteca predeterminada,
			// authPacket: biblioteca predeterminada,
			// voluntad: biblioteca predeterminada,
			// transformWsUrl: biblioteca predeterminada,
			// volver a suscribirse: biblioteca predeterminada
		};

		Object.assign(options, this.settings);

		// Si no se especifica, utilice memoria

		// Crea una terminal de envío y recepción de mensajes mqtt
		this.endpoint = mqtt.connect(this.broker, options);
		this.endpoint.on('connect', this[_ON_CONNECTED].bind(this));  // 已连接
		this.endpoint.on('close', async () => {
			await this.onDisconnected();
			this.endpoint.removeAllListeners();
			await new Promise(resolve => this.endpoint.end(true, resolve));
			await this.connect();
		});  // Desconectado (la desconexión requiere el cierre forzado de la conexión y la reconexión, de lo contrario la nueva suscripción será inválida)
		this.endpoint.on('error', this.onError.bind(this)); // Error
		this.endpoint.on('reconnect', this.onReconnecting.bind(this));  // Reconectando
		this.endpoint.on('message', this.onData.bind(this));  //recibir datos
	}
	/**
	 * desconectar
	 */
	async disconnect() {
		// Limpiar oyentes, desconectar y destruir clientes
	    let subscribedTopics = this.subscribedTopics;
	    for (let topic in subscribedTopics) {
	    	try {
	    		await this.unsubscribe(topic);
			} catch (e) {  // El error no afecta a otras suscripciones
                (logger && logger.error.bind(logger) || console.error)(`Error unsubscribing topic <${topic}>: ${e.stack}`);
            }
        }
		this.endpoint.removeAllListeners();
		await new Promise(resolve => this.endpoint.end(true, resolve));
		this.endpoint = null;
	}
	/**
	* Reconectar
	*/
	async reconnect() {
		this.endpoint.reconnect();
	}
// —— Conexión y desconexión del transporte mqtt ———————————— fin

// —— gancho privado de transporte mqtt (reservado) ———————————— begin
	/**
	 * Devolución de llamada conectada (privada)
	 */
	async [_ON_CONNECTED]() {
// Deje el código para ver: suscríbase al tema suscrito después de conectarse, porque es posible que no se suscriba automáticamente después de la desconexión
	    // deje que Temassuscritos = this.Temassuscritos;
	    // para (dejar tema en subscribedTopics) {
	    // intentar {
	    // espera esto.subscribe(tema, subscribedTopics[tema].opciones);
		// } catch (e) { // El error no afecta a otras suscripciones
        // (logger && logger.error || console.error)(`Error al suscribirse al tema <${topic}>: ${e.stack}`);
        // }
        // }
        await this.onConnected();
	}
	/**
	 * Devolución de llamada desconectada (privada)
	 */
	async [_ON_DISCONNECTED]() {

	}
// —— gancho privado de transporte mqtt (reservado) ———————————— fin

// —— gancho de transporte mqtt ————————————— comenzar
	/**
	 * Devolución de llamada conectada
	 */
	onConnected() {

    }
	/**
	 * Desconectado
	 */
	onDisconnected() {

    }
	/**
	 * ya esta mal
	 * @param {Object} e instancia de error
	 */
	onError(e) {}

    /**
     * Recibió
     * @param topic
     * @param data
     * @param packet
     * @returns {{data: *, context: {topic: *, packet: *}}}
     */
    onData(topic, data, packet) {
        return { data, context: { topic, packet } };
    }
// —— gancho de transporte mqtt ———————————— fin

// —— mqtt transport envía y recibe ———————————— comienza
    /**
     * enviar
     */
	async send({ data: message, originalData: _message, options = {} } = {}) {
        if (options.topic) await this.publish(options.topic, message, options);
    }
	async subscribe(topic, options = {}, callback) {
		options.qos = 2;  // TODO temp code
		//Nota: Si se usa promisify directamente, el segundo parámetro debe ser callback, pero aquí son opciones.
		let { err, granted } = await new Promise(resolve => {
		    this.endpoint.subscribe(topic, (err, granted) => {
		        resolve({ err, granted })
            });
        });
		// se concede una matriz de {tema, qos} donde:
        // El tema es un tema suscrito
        // qos es el nivel de qos otorgado
        // concedido.forEach(g => {
        // este.subscribedTopics[g.topic] = g;
        // });
        granted.forEach(g => { this.subscribedTopics[g.topic] = { topic: g.topic, options }; });
        if (typeof callback === 'function') callback(err, granted);
	}
	async unsubscribe(topic, callback) {
		// Nota: Si se usa promisify directamente, el segundo parámetro debe ser callback, pero aquí son opciones
		// Nota: El cliente mqtt debe cancelar la suscripción en el estado conectado para evitar el bloqueo
		let { err } = this.endpoint.connected && await new Promise(resolve => {
			this.endpoint.unsubscribe(topic, err => {
				resolve({ err })
			});
		}) || {};
        // granted is an array of {topic, qos} where:
        // 	topic is a subscribed to topic
        // 	qos is the granted qos level on it
        let topicObj = (typeof topic === 'string') ? [topic] : topic;
        let topics = Array.isArray(topicObj) ? topicObj : Object.keys(topicObj);
        topics.forEach(topic => {
            delete this.subscribedTopics[topic];
        });
        if (typeof callback === 'function') callback(err);
	}
	async publish(topic, message, options = {}, callback) {
		options.qos = 2;  // TODO temp code
		await promisify(this.endpoint.publish).call(this.endpoint, topic, message, options);
        if (typeof callback === 'function') callback();
	}
// —— mqtt transport envía y recibe ———————————— fin
}

module.exports = MQTTTransfer;
