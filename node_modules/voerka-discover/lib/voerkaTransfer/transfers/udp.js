// 内置或外部工具
const dgram = require('dgram');

// 传输器基类
const { TransferBase } = require('./base');

class UDPTransfer extends TransferBase {
// —— udp传输器初始化 ———————————— begin
    constructor(settings) {
        super(settings);
        // 支持配置加入多个组播
        let multicast = this.settings.multicast;
        if (!Array.isArray(multicast)) this.settings.multicast = [multicast];
    }
// —— udp传输器初始化 ———————————— end

// —— udp传输器属性 ———————————— begin
	get displayName() {
		return `Multicast Transfer <${this.name}> [Client -> ${JSON.stringify(this.multicast)} - ${this.deviceUdpPort} <- Device]`;
	}
	get udpPort() {
		return this.settings.udpPort;
	}
	get deviceUdpPort() {
		return this.settings.deviceUdpPort;
	}
	get multicast() {
		return this.settings.multicast;
	}
// —— udp传输器属性 ———————————— end

// —— udp传输器连接和断开 ———————————— begin
    async connect() {
        let client = this.client = dgram.createSocket('udp4');

        client.on('listening', this.onConnected.bind(this));  // 已连接
        client.on('close', this.onDisconnected.bind(this));  // 已断开
        client.on('error', this.onError.bind(this));  // 已错误
        client.on('message', this.onData.bind(this));  // 收到数据

        // 只绑定到服务器本地 ip，
        // 若直接绑定组播地址 client.bind(this.port, this.address)
        // 则不能支持加入多个组播组，除非再绑定一个端口
        client.bind(this.udpPort);  // 组播端口不能绑定地址，否则不能接收组播消息
        // client.bind(this.deviceUdpPort, VIServer.ip);  // 如果组播和非组播要分开处理，则需要两个 client
    }
    async disconnect() {
        this.client.close();
    }
// —— udp传输器连接和断开 ———————————— end

// —— udp传输器钩子 ———————————— begin
	/**
	 * 已连接回调
	 */
	onConnected() {}
	/**
	 * 已断开
	 */
	onDisconnected() {}
	/**
	 * 已错误
	 * @param {Object} e 错误实例
	 */
	onError(e) {}
    /**
     * 已收到
     * @param topic
     * @param data
     * @param packet
     * @returns {{data: *, context: {topic: *, packet: *}}}
     */
    onData(data, rinfo) {
        return { data, context: { rinfo } };
    }
// —— udp传输器钩子 ———————————— end

// —— mqtt传输器发送和接收 ———————————— begin
	async send({ data, originalData, options = {} } = {}) {
	    if (options.address) {
            let [addr, port] = options.address.split(':');
            if (addr && port) this.client.send(data, port, addr);
        }
	}
// —— mqtt传输器发送和接收 ———————————— end

// —— udp传输器 组播加入和退出 ———————————— begin
    actMembership(act) {
        /**
         * 传入 组播地址 或 组播地址列表
         * 或 组播对象 或 组播对象列表
         */
        let doActMembership = this.client[`${act}Membership`].bind(this.client);
        let actMembership = (function () {
            let argLen = arguments.length;
            if (argLen === 1) {
                let arg = arguments[0];
                if (typeof arg === 'string') {  // 组播地址 'mul.ti.cast.addr'
                    doActMembership(arg);
                }
                else if (Array.isArray(arg)) {  // 组播列表 [{...}, {...}, {...}] or ['...', '...', '...']
                    for (let i in arg) {
                        actMembership(arg[i]);
                    }
                } else if (arg.interface) {     // 组播对象 { addr, interface }
                    doActMembership(arg.addr, arg.interface)
                } else {                        // 组播对象 { addr }
                    doActMembership(arg.addr);
                }
            }
            if (argLen === 2) doActMembership(...arguments);
        }).bind(this);
        return actMembership;
    }
    addMembership() {
	    return this.actMembership('add')(...arguments);
    }
    dropMembership() {
	    return this.actMembership('drop')(...arguments);
    }
// —— udp传输器 组播加入和退出 ———————————— end
}

// 有条件单例
let singleTons = {};
UDPTransfer.enableSingleton = (self, settings) => {
    let singleTon = singleTons[settings.udpPort];
    if (!singleTon) singleTons[settings.udpPort] = self;
    return singleTon;
};

module.exports = UDPTransfer;