// Herramientas integradas o externas
const dgram = require('dgram');

//Clase base del transmisor
const { TransferBase } = require('./base');

class UDPTransfer extends TransferBase {
// —— inicialización del transporte udp ———————————— comenzar
    constructor(settings) {
        super(settings);
        //Configuración de soporte para unirse a múltiples multidifusiones
        let multicast = this.settings.multicast;
        if (!Array.isArray(multicast)) this.settings.multicast = [multicast];
    }
// —— inicialización del transporte udp ———————————— fin

// —— propiedades de transporte udp ————————————— comenzar
	get displayName() {
		return `Multicast Transfer <${this.name}> [Client -> ${JSON.stringify(this.multicast)} - ${this.deviceUdpPort} <- Device]`;
	}
	get udpPort() {
		return this.settings.udpPort;
	}
	get deviceUdpPort() {
		return this.settings.deviceUdpPort;
	}
	get multicast() {
		return this.settings.multicast;
	}
// —— propiedades de transporte udp ———————————— fin

// —— conexión y desconexión de transporte udp ———————————— comenzar
    async connect() {
        let client = this.client = dgram.createSocket('udp4');

        client.on('listening', this.onConnected.bind(this)); // conectado
        client.on('close', this.onDisconnected.bind(this));  // desconectado
        client.on('error', this.onError.bind(this));  // Error
        client.on('message', this.onData.bind(this));  //recibir datos

        //Solo vincular a la IP local del servidor,
        // Si vincula la dirección de multidifusión directamente client.bind(this.port, this.address)
        // No se puede admitir la unión de varios grupos de multidifusión a menos que vincule otro puerto
        client.bind(this.udpPort);  // El puerto de multidifusión no se puede vincular a una dirección, de lo contrario no se podrán recibir mensajes de multidifusión
        // client.bind(this.deviceUdpPort, VIServer.ip);  // Si se deben procesar por separado la multidifusión y la no multidifusión, se deben procesar dos client
    }
    async disconnect() {
        this.client.close();
    }
// —— conexión y desconexión de transporte udp ———————————— fin

// —— gancho de transporte udp ————————————— comenzar
	/**
	 * Devolución de llamada conectada
	 */
	onConnected() {}
	/**
	 * Desconectado
	 */
	onDisconnected() {}
	/**
	 * ya esta mal
	 * @param {Object} e Instancia de error
	 */
	onError(e) {}
    /**
     * Recibió
     * @param topic
     * @param data
     * @param packet
     * @returns {{data: *, context: {topic: *, packet: *}}}
     */
    onData(data, rinfo) {
        return { data, context: { rinfo } };
    }
// —— gancho de transporte udp ———————————— fin
// —— mqtt transport envía y recibe ———————————— comienza
	async send({ data, originalData, options = {} } = {}) {
	    if (options.address) {
            let [addr, port] = options.address.split(':');
            if (addr && port) this.client.send(data, port, addr);
        }
	}
// —— mqtt transport envía y recibe ———————————— fin
//—— unirse y salir de multidifusión del transmisor udp ———————————— comenzar
    actMembership(act) {
        /**
        * Pasar una dirección de multidifusión o una lista de direcciones de multidifusión
         * o objeto de multidifusión o lista de objetos de multidifusión
         */
        let doActMembership = this.client[`${act}Membership`].bind(this.client);
        let actMembership = (function () {
            let argLen = arguments.length;
            if (argLen === 1) {
                let arg = arguments[0];
                if (typeof arg === 'string') {  // Dirección de multidifusión 'mul.ti.cast.addr'
                    doActMembership(arg);
                }
                else if (Array.isArray(arg)) {  // Lista de multidifusión [{...}, {...}, {...}] o ['...', '...', '...']
                    for (let i in arg) {
                        actMembership(arg[i]);
                    }
                } else if (arg.interface) {     // Objeto de multidifusión {dirección, interfaz}
                    doActMembership(arg.addr, arg.interface)
                } else {                        // Objeto de multidifusión {addr}
                    doActMembership(arg.addr);
                }
            }
            if (argLen === 2) doActMembership(...arguments);
        }).bind(this);
        return actMembership;
    }
    addMembership() {
	    return this.actMembership('add')(...arguments);
    }
    dropMembership() {
	    return this.actMembership('drop')(...arguments);
    }
//—— unirse y salir de multidifusión del transmisor udp ———————————— fin
}

//Singleton condicional
let singleTons = {};
UDPTransfer.enableSingleton = (self, settings) => {
    let singleTon = singleTons[settings.udpPort];
    if (!singleTon) singleTons[settings.udpPort] = self;
    return singleTon;
};

module.exports = UDPTransfer;