/**

 Proporciona algunas funciones relacionadas con la programación funcional.

 Autor: wxzhang

 */

/**
 * Función parcial
 *
 * let {parcial} = require('functools')
 * deja que foo = función(x,y,z) { devuelve (x*y) + z }
* myfoo = parcial(foo)(1)
 * mifoo(2,3)========foo(1,2,3)
 * @return {Function}
 */
function partial () {
    let _args = Array.from(arguments);
    let fn = _args[0];
    let args = _args.slice(1);
    return function() {
        if (arguments.length + args.length >= fn.length) {
            let x = args.concat(Array.from(arguments));
            return fn(...x)
        } else {
            let x = args.concat(Array.from(arguments));
            return partial(fn,...x);
        }
    }
}

partial.rapply = function() {
    let _args = Array.from(arguments);
    let fn = _args[0];
    let args = _args.slice(1);
    return function() {
        if ((arguments.length + args.length) >= fn.length) {
            let x = Array.from(arguments).concat(args);
            return fn(...x)
        } else {
            let x = Array.from(arguments).concat(args);
            return partial.rapply(fn,...x);
        }
    }
};

function hook(obj, hooks) {
    hooks.forEach(_hook => {
        let original = _hook.original;
        // El método original solo se puede conectar si existe en la instancia
        if (typeof obj[original.name] === 'function') {
            obj[original.name] = {
                [original.name]: async (...args) => {
                    try {
                        // Obtener el resultado de la ejecución del gancho hacia adelante
                        let hookResult;
                        if (typeof _hook.before === 'function') {
                            hookResult = await _hook.before.call(obj, ...args);
                        }
                        // Si el resultado contiene un objeto err (error de capa de aplicación), devuélvalo directamente
                        // Si la estructura contiene un objeto que se devolverá directamente, devuélvalo directamente
                        if (hookResult) {
                            if (hookResult.err) return hookResult;
                            if (hookResult.hasOwnProperty(hook.return)) return hookResult[hook.return];
                        }
                        // De lo contrario, ejecute la función original. Si el gancho hacia adelante tiene resultado, pásalo.，否则传入原参数
                        hookResult = hookResult ?
                            await original.call(obj, hookResult)
                            : await original.call(obj, ...args);

                        // Si el resultado contiene un objeto err (error de capa de aplicación), se devuelve directamente
                        if (hookResult && hookResult.err) return hookResult;
                        // Si hay una función de gancho hacia atrás, se ejecutará y se devolverá, de lo contrario, se devolverá directamente.
                        if (typeof _hook.after === 'function') {
                            return hookResult ?
                                await _hook.after.call(obj, hookResult, ...args)
                                : await _hook.after.call(obj, ...args);
                        }
                        else {
                            return hookResult;
                        }
                    } catch (e) {
                        if (typeof _hook.error === 'function') await _hook.error.call(obj, e);
                        else throw e;
                    }
                }
            }[original.name];
        }
    });
}
hook.return = Symbol('hookReturn');

module.exports ={
    partial, hook
};