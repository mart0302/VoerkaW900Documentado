/**

 提供一些函数编程相关的函数

 Author : wxzhang

 */

/**
 * 偏函数
 *
 *  let { partial }= require('functools')
 *  let foo = function(x,y,z) { return (x*y) + z }
*   myfoo = partial(foo)(1)
 *  myfoo(2,3)========foo(1,2,3)
 * @return {Function}
 */
function partial () {
    let _args = Array.from(arguments);
    let fn = _args[0];
    let args = _args.slice(1);
    return function() {
        if (arguments.length + args.length >= fn.length) {
            let x = args.concat(Array.from(arguments));
            return fn(...x)
        } else {
            let x = args.concat(Array.from(arguments));
            return partial(fn,...x);
        }
    }
}

partial.rapply = function() {
    let _args = Array.from(arguments);
    let fn = _args[0];
    let args = _args.slice(1);
    return function() {
        if ((arguments.length + args.length) >= fn.length) {
            let x = Array.from(arguments).concat(args);
            return fn(...x)
        } else {
            let x = Array.from(arguments).concat(args);
            return partial.rapply(fn,...x);
        }
    }
};

function hook(obj, hooks) {
    hooks.forEach(_hook => {
        let original = _hook.original;
        // 实例上存在原方法才可以挂钩
        if (typeof obj[original.name] === 'function') {
            obj[original.name] = {
                [original.name]: async (...args) => {
                    try {
                        // 获得前向钩子执行结果
                        let hookResult;
                        if (typeof _hook.before === 'function') {
                            hookResult = await _hook.before.call(obj, ...args);
                        }
                        // 如果结果中包含 err 对象（应用层 err），则直接返回
                        // 如果结构中包含要直接返回的对象，则直接返回
                        if (hookResult) {
                            if (hookResult.err) return hookResult;
                            if (hookResult.hasOwnProperty(hook.return)) return hookResult[hook.return];
                        }
                        // 否则执行原函数，如果前向钩子有结果，则传入该结果，否则传入原参数
                        hookResult = hookResult ?
                            await original.call(obj, hookResult)
                            : await original.call(obj, ...args);

                        // 如果结果中包含 err 对象（应用层 err），则直接返回
                        if (hookResult && hookResult.err) return hookResult;
                        // 如果有后向钩子函数，则执行并返回，否则直接返回
                        if (typeof _hook.after === 'function') {
                            return hookResult ?
                                await _hook.after.call(obj, hookResult, ...args)
                                : await _hook.after.call(obj, ...args);
                        }
                        else {
                            return hookResult;
                        }
                    } catch (e) {
                        if (typeof _hook.error === 'function') await _hook.error.call(obj, e);
                        else throw e;
                    }
                }
            }[original.name];
        }
    });
}
hook.return = Symbol('hookReturn');

module.exports ={
    partial, hook
};