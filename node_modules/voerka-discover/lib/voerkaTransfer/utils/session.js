/*

    administrador de sesión

    Usos de configuración mínima:

    // 1. Crear una instancia de un administrador de sesiones
    constante sessionManager = nuevo SessionManager();

    // 2. Inicie este administrador de sesiones
    sessionManager.start();

    // 3. Crear una sesión
    constante sesión = sessionManager.createSession();

    // 4. Ejecute tareas en esta sesión y espere a que la tarea se complete y la sesión finalice.
    // Nota: el ejecutor es la función de la tarea
    esperar sesión.toBeComplete({ ejecutor });

    // Lo siguiente se encuentra en una ubicación diferente a la anterior, como dentro del ejecutor.

    // 5. Obtenga esta sesión
    // Nota: sid es el id de la sesión
    constante sesión = sessionManager.getSession(sid);

    // 6. Tarea completada, finaliza esta sesión
    sesión.completa();

 */

const ms = require('ms');

const SESSION_STATUS = {
    INITIALIZED: Symbol('INITIALIZED'),
    STARTED: Symbol('STARTED'),
    COMPLETED: Symbol('COMPLETED'),
    TIMEOUT: Symbol('TIMEOUT')
};

class SessionTimeoutError extends Error {}

class Session {
    constructor({ sid, timeout = '200ms', logPrefix = '' } = {}) {
        logPrefix = logPrefix || (logPrefix + ' ');
        if (!sid) {
            logger.error(`${logPrefix}错误 会话实例化必须传入非空 sid`);
        }
        else {
            this.sid = sid;
            this.data = {};
            this.timeoutMilliseconds = typeof timeout === 'string' ? ms(timeout) : timeout;
            this.logPrefix = logPrefix;
            this.onStatusCallbacks = {};
           // este.sessionResolve = este.sessionReject = () => {};
            this.setStatus(SESSION_STATUS.INITIALIZED);
            this._callback(SESSION_STATUS.INITIALIZED);
        }
    }
    setStatus(status) {
        this.status = status;
    }
    isStatus(status) {
        return this.status === status;
    }
    async start({ data, executor }) {
        if (this.isStatus(SESSION_STATUS.INITIALIZED)) {
            this.timeoutError = new SessionTimeoutError('会话超时');
            this.startTime = new Date();
            this.data = data;
            this.setStatus(SESSION_STATUS.STARTED);
            this._callback(SESSION_STATUS.STARTED);
            this.sessionPromise = new Promise(async (resolve, reject) => {
                this.sessionResolve = resolve;
                this.sessionReject = reject;
                if (typeof executor === 'function') {
                    // Independientemente de si es asincrónico o no, no es necesario esperar explícitamente, porque la clave es que la sesión solo finalizará cuando el estado de la sesión sea completado
                    // Pero si la función asincrónica no espera, es posible que no se detecte el error del ejecutor, lo que genera un mensaje de error asincrónico no controlado.
                    // Además, la función sincrónica await.catch(e => {...}) no es válida
                    try { await executor(data); } catch (e) { reject(e); }
                }
            });
            return await this.sessionPromise;
        }
        else {
            logger.warn(`${this.logPrefix}警告 重复启动会话`);
        }
    }
    async toBeComplete({ data = {}, executor }) {
        if (typeof arguments[0] === 'function') executor = arguments[0];
        return await this.start({ data, executor });
    }
    complete(result) {
        this.setStatus(SESSION_STATUS.COMPLETED);
        this.sessionResolve(result);
        this._callback(SESSION_STATUS.COMPLETED);
    }
    timeout(result) {
        this.setStatus(SESSION_STATUS.TIMEOUT);
        this.sessionReject(this.timeoutError);
        this._callback(SESSION_STATUS.TIMEOUT);
    }
    on(status, callback) {
        if (status && typeof callback === 'function') {
            let onStatusCallbacks = this.onStatusCallbacks[status];
            if (Array.isArray(onStatusCallbacks)) {
                onStatusCallbacks.push(callback);
            }
            else {
                this.onStatusCallbacks[status] = [callback];
            }
        }
    }
    _callback(status) {
        for (let callback of this.onStatusCallbacks[status] || []) {
            // No espere para evitar el bloqueo asincrónico
            callback(this);
        }
    }
}

const emptySession = new Session({ sid: Symbol('EMPTY') });

class SessionManager {
    constructor({ traceInterval = '1s', sessionTimeout = '2s', logPrefix = '' } = {}) {
        traceInterval = typeof traceInterval === 'string' ? ms(traceInterval) : traceInterval;
        sessionTimeout = typeof sessionTimeout === 'string' ? ms(sessionTimeout) : sessionTimeout;
        this.sessions = {/* todas las sesiones iniciadas */};
        this.sid = 0;
        if (sessionTimeout) {
            this.sessionTimeout = Math.max(sessionTimeout, 500);
            this.traceInterval = Math.min(traceInterval, this.sessionTimeout);
        }
        else {
            this.sessionTimeout = sessionTimeout || 0;
            this.traceInterval = traceInterval || 0;
        }
        this.logPrefix = logPrefix || (logPrefix + ' ');
        this.onSessionStatusCallbacks = {};
    }
    start() {
      //Deja el código para verlo
        // si (este._isStarted || !este.traceInterval) devolver;
        // esto._isStarted = verdadero;
        // deje que traceSessions = () => {
        // dejar sesiones = this.sessions;
        // para (dejar sid en sesiones) {
        // deje que sesión = sesiones[sid];
        // si (sesión.isStatus(ESTADO_DE_SESIÓN.INICIADO)) {
        // si (nueva fecha().getTime() - sesión.startTime >= sesión.timeoutMilliseconds) {
        // sesión.timeout();
        // }
        // }
        // demás {
        //eliminar sesiones[sid];
        // }
        // }
        // este.tracerId = setTimeout(traceSessions, este.traceInterval);
        // };
        // este.tracerId = setTimeout(traceSessions, este.traceInterval);
    }
    createSession(options = {}) {
        options.timeout = options.timeout || this.sessionTimeout;
        options.logPrefix = options.logPrefix || this.logPrefix;
        options.sid = options.sid || ++this.sid;
        let session = new Session(options);
        session.on(SESSION_STATUS.STARTED, (session) => {
            this.register(session);
        });
        session.on(SESSION_STATUS.COMPLETED, (session) => {
            delete this.sessions[session.sid];
        });
        for (let STATUS in SESSION_STATUS) {
            session.on(STATUS, this._callback);
        }
        session.on(SESSION_STATUS.STARTED, () => setTimeout(() => {
            session.timeout();
            delete this.sessions[session.sid];
        }, session.timeoutMilliseconds));
        return session;
    }
    getSession(sid) {
        return this.sessions[sid];
    }
    register(session) {
        this.sessions[session.sid] = session;
    }
    stop() {
        clearTimeout(this.tracerId);
        this.sessions = {};
    }
    on(sessionStatus, callback) {
        if (sessionStatus && typeof callback === 'function') {
            let onSessionStatusCallbacks = this.onSessionStatusCallbacks[sessionStatus];
            if (Array.isArray(onSessionStatusCallbacks)) {
                onSessionStatusCallbacks.push(callback);
            }
            else {
                this.onSessionStatusCallbacks[sessionStatus] = [callback];
            }
        }
    }
    _callback(session) {
        for (let callback of this.onSessionStatusCallbacks[session.status] || []) {
            // No espere para evitar el bloqueo asincrónico
            callback(this);
        }
    }
}

module.exports = {
    SESSION_STATUS,
    Session,
    SessionManager,
    SessionTimeoutError,
};