/*

    administrador de sesión

    Usos de configuración mínima:

    // 1. Crear una instancia de un administrador de sesiones
    constante sessionManager = nuevo SessionManager();

    // 2. Inicie este administrador de sesiones
    sessionManager.start();

    // 3. Crear una sesión
    constante sesión = sessionManager.createSession();

    // 4. Ejecute tareas en esta sesión y espere a que la tarea se complete y la sesión finalice.
    // Nota: el ejecutor es la función de la tarea
    esperar sesión.toBeComplete({ ejecutor });

    // Lo siguiente se encuentra en una ubicación diferente a la anterior, como dentro del ejecutor.

    // 5. Obtenga esta sesión
    // Nota: sid es el id de la sesión
    constante sesión = sessionManager.getSession(sid);

    // 6. Tarea completada, finaliza esta sesión
    sesión.completa();

 */

const ms = require('ms');

const SESSION_STATUS = {
    INITIALIZED: Symbol('INITIALIZED'),
    STARTED: Symbol('STARTED'),
    COMPLETED: Symbol('COMPLETED'),
    TIMEOUT: Symbol('TIMEOUT')
};

class SessionTimeoutError extends Error {}

class Session {
    constructor({ sid, timeout = '2s', logPrefix = '' } = {}) {
        logPrefix = logPrefix || (logPrefix + ' ');
        if (!sid) {
            logger.error(`${logPrefix}错误 会话实例化必须传入非空 sid`);
        }
        else {
            this.sid = sid;
            this.data = {};
            this.timeoutMilliseconds = ms(timeout);
            this.logPrefix = logPrefix;
            this.onStatusCallbacks = {};
            // this.sessionResolve = this.sessionReject = () => {};
            this.setStatus(SESSION_STATUS.INITIALIZED);
            this._callback(SESSION_STATUS.INITIALIZED);
        }
    }
    setStatus(status) {
        this.status = status;
    }
    isStatus(status) {
        return this.status === status;
    }
    async start({ data, executor }) {
        if (this.isStatus(SESSION_STATUS.INITIALIZED)) {
            this.startTime = new Date();
            this.data = data;
            this.setStatus(SESSION_STATUS.STARTED);
            this._callback(SESSION_STATUS.STARTED);
            this.sessionPromise = new Promise(async (resolve, reject) => {
                this.sessionResolve = resolve;
                this.sessionReject = reject;
                if (typeof executor === 'function') {
                    // Independientemente de si es asincrónico o no, no es necesario esperar explícitamente, porque la clave es que la sesión solo finalizará cuando el estado de la sesión sea completado
                    // Pero si la función asincrónica no espera, es posible que no se detecte el error del ejecutor, lo que genera un mensaje de error asincrónico no controlado.
                    // Además, la función sincrónica await.catch(e => {...}) no es válida
                    try { await executor(data); } catch (e) { reject(e); }
                }
            });
            return await this.sessionPromise;
        }
        else {
            logger.warn(`${this.logPrefix}警告 重复启动会话`);
        }
    }
    async toBeComplete({ data = {}, executor }) {
        if (typeof arguments[0] === 'function') executor = arguments[0];
        return await this.start({ data, executor });
    }
    complete(result) {
        this.setStatus(SESSION_STATUS.COMPLETED);
        this.sessionResolve(result);
        this._callback(SESSION_STATUS.COMPLETED);
    }
    timeout(result) {
        this.setStatus(SESSION_STATUS.TIMEOUT);
        this.sessionReject(new SessionTimeoutError('会话超时'));
        this._callback(SESSION_STATUS.TIMEOUT);
    }
    on(status, callback) {
        if (status && typeof callback === 'function') {
            let onStatusCallbacks = this.onStatusCallbacks[status];
            if (Array.isArray(onStatusCallbacks)) {
                onStatusCallbacks.push(callback);
            }
            else {
                this.onStatusCallbacks[status] = [callback];
            }
        }
    }
    _callback(status) {
        for (let callback of this.onStatusCallbacks[status] || []) {
            // No espere para evitar el bloqueo asincrónico
            callback(this);
        }
    }
}

const emptySession = new Session({ sid: Symbol('EMPTY') });

class SessionManager {
    constructor({ traceInterval = '1s', sessionTimeout = '2s', logPrefix = '' } = {}) {
        this.sessions = {/* all started sessions */};
        this.sid = 0;
        this.traceInterval = ms(traceInterval);
        this.sessionTimeout = sessionTimeout;
        this.logPrefix = logPrefix || (logPrefix + ' ');
        this.onSessionStatusCallbacks = {};
    }
    start() {
        if (this._isStarted) return;
        this._isStarted = true;
        let traceSessions = () => {
            let sessions = this.sessions;
            for (let sid in sessions) {
                let session = sessions[sid];
                if (session.isStatus(SESSION_STATUS.STARTED)) {
                    if (new Date().getTime() - session.startTime >= session.timeoutMilliseconds) {
                        session.timeout();
                    }
                }
                else {
                    delete sessions[sid];
                }
            }
            this.tracerId = setTimeout(traceSessions, this.traceInterval);
        };
        this.tracerId = setTimeout(traceSessions, this.traceInterval);
    }
    createSession(options = {}) {
        options = Object.assign({
            timeout: this.sessionTimeout,
            logPrefix: this.logPrefix
        }, options);
        options.sid = options.sid || ++this.sid;
        let session = new Session(options);
        session.on(SESSION_STATUS.STARTED, (session) => {
            this.register(session);
        });
        session.on(SESSION_STATUS.COMPLETED, (session) => {
            delete this.sessions[session.sid];
        });
        for (let STATUS in SESSION_STATUS) {
            session.on(STATUS, this._callback);
        }
        return session;
    }
    getSession(sid) {
        return this.sessions[sid];
    }
    register(session) {
        this.sessions[session.sid] = session;
    }
    stop() {
        clearTimeout(this.tracerId);
        this.sessions = {};
    }
    on(sessionStatus, callback) {
        if (sessionStatus && typeof callback === 'function') {
            let onSessionStatusCallbacks = this.onSessionStatusCallbacks[sessionStatus];
            if (Array.isArray(onSessionStatusCallbacks)) {
                onSessionStatusCallbacks.push(callback);
            }
            else {
                this.onSessionStatusCallbacks[sessionStatus] = [callback];
            }
        }
    }
    _callback(session) {
        for (let callback of this.onSessionStatusCallbacks[session.status] || []) {
            // No espere para evitar el bloqueo asincrónico
            callback(this);
        }
    }
}

module.exports = {
    SESSION_STATUS,
    Session,
    SessionManager,
    SessionTimeoutError,
};