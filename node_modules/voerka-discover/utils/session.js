/*

    会话管理器

    最小配置使用：

    // 1. 实例化一个会话管理器
    const sessionManager = new SessionManager();

    // 2. 启动这个会话管理器
    sessionManager.start();

    // 3. 创建一个会话
    const session = sessionManager.createSession();

    // 4. 在这个会话上运行任务并等待任务完成及会话结束
    //    注： executor 为任务函数
    await session.toBeComplete({ executor });

    // 以下在不同于以上的其它位置，如 executor 的内部

    // 5. 获得这个会话
    //    注： sid 为会话 id
    const session = sessionManager.getSession(sid);

    // 6. 任务完成，结束这个会话
    session.complete();

 */

const ms = require('ms');

const SESSION_STATUS = {
    INITIALIZED: Symbol('INITIALIZED'),
    STARTED: Symbol('STARTED'),
    COMPLETED: Symbol('COMPLETED'),
    TIMEOUT: Symbol('TIMEOUT')
};

class SessionTimeoutError extends Error {}

class Session {
    constructor({ sid, timeout = '2s', logPrefix = '' } = {}) {
        logPrefix = logPrefix || (logPrefix + ' ');
        if (!sid) {
            logger.error(`${logPrefix}错误 会话实例化必须传入非空 sid`);
        }
        else {
            this.sid = sid;
            this.data = {};
            this.timeoutMilliseconds = ms(timeout);
            this.logPrefix = logPrefix;
            this.onStatusCallbacks = {};
            // this.sessionResolve = this.sessionReject = () => {};
            this.setStatus(SESSION_STATUS.INITIALIZED);
            this._callback(SESSION_STATUS.INITIALIZED);
        }
    }
    setStatus(status) {
        this.status = status;
    }
    isStatus(status) {
        return this.status === status;
    }
    async start({ data, executor }) {
        if (this.isStatus(SESSION_STATUS.INITIALIZED)) {
            this.startTime = new Date();
            this.data = data;
            this.setStatus(SESSION_STATUS.STARTED);
            this._callback(SESSION_STATUS.STARTED);
            this.sessionPromise = new Promise(async (resolve, reject) => {
                this.sessionResolve = resolve;
                this.sessionReject = reject;
                if (typeof executor === 'function') {
                    // 不论是否异步，都不用显式 await，因为关键在只有 session 状态为 completed 时会话才会结束
                    // 但如果异步函数不 await ，则 executor 错误就有可能不能捕捉到，导致提示未处理的异步错误
                    // 另外，同步函数 await.catch(e => {...}) 无效
                    try { await executor(data); } catch (e) { reject(e); }
                }
            });
            return await this.sessionPromise;
        }
        else {
            logger.warn(`${this.logPrefix}警告 重复启动会话`);
        }
    }
    async toBeComplete({ data = {}, executor }) {
        if (typeof arguments[0] === 'function') executor = arguments[0];
        return await this.start({ data, executor });
    }
    complete(result) {
        this.setStatus(SESSION_STATUS.COMPLETED);
        this.sessionResolve(result);
        this._callback(SESSION_STATUS.COMPLETED);
    }
    timeout(result) {
        this.setStatus(SESSION_STATUS.TIMEOUT);
        this.sessionReject(new SessionTimeoutError('会话超时'));
        this._callback(SESSION_STATUS.TIMEOUT);
    }
    on(status, callback) {
        if (status && typeof callback === 'function') {
            let onStatusCallbacks = this.onStatusCallbacks[status];
            if (Array.isArray(onStatusCallbacks)) {
                onStatusCallbacks.push(callback);
            }
            else {
                this.onStatusCallbacks[status] = [callback];
            }
        }
    }
    _callback(status) {
        for (let callback of this.onStatusCallbacks[status] || []) {
            // 不 await 以免异步阻塞
            callback(this);
        }
    }
}

const emptySession = new Session({ sid: Symbol('EMPTY') });

class SessionManager {
    constructor({ traceInterval = '1s', sessionTimeout = '2s', logPrefix = '' } = {}) {
        this.sessions = {/* all started sessions */};
        this.sid = 0;
        this.traceInterval = ms(traceInterval);
        this.sessionTimeout = sessionTimeout;
        this.logPrefix = logPrefix || (logPrefix + ' ');
        this.onSessionStatusCallbacks = {};
    }
    start() {
        if (this._isStarted) return;
        this._isStarted = true;
        let traceSessions = () => {
            let sessions = this.sessions;
            for (let sid in sessions) {
                let session = sessions[sid];
                if (session.isStatus(SESSION_STATUS.STARTED)) {
                    if (new Date().getTime() - session.startTime >= session.timeoutMilliseconds) {
                        session.timeout();
                    }
                }
                else {
                    delete sessions[sid];
                }
            }
            this.tracerId = setTimeout(traceSessions, this.traceInterval);
        };
        this.tracerId = setTimeout(traceSessions, this.traceInterval);
    }
    createSession(options = {}) {
        options = Object.assign({
            timeout: this.sessionTimeout,
            logPrefix: this.logPrefix
        }, options);
        options.sid = options.sid || ++this.sid;
        let session = new Session(options);
        session.on(SESSION_STATUS.STARTED, (session) => {
            this.register(session);
        });
        session.on(SESSION_STATUS.COMPLETED, (session) => {
            delete this.sessions[session.sid];
        });
        for (let STATUS in SESSION_STATUS) {
            session.on(STATUS, this._callback);
        }
        return session;
    }
    getSession(sid) {
        return this.sessions[sid];
    }
    register(session) {
        this.sessions[session.sid] = session;
    }
    stop() {
        clearTimeout(this.tracerId);
        this.sessions = {};
    }
    on(sessionStatus, callback) {
        if (sessionStatus && typeof callback === 'function') {
            let onSessionStatusCallbacks = this.onSessionStatusCallbacks[sessionStatus];
            if (Array.isArray(onSessionStatusCallbacks)) {
                onSessionStatusCallbacks.push(callback);
            }
            else {
                this.onSessionStatusCallbacks[sessionStatus] = [callback];
            }
        }
    }
    _callback(session) {
        for (let callback of this.onSessionStatusCallbacks[session.status] || []) {
            // 不 await 以免异步阻塞
            callback(this);
        }
    }
}

module.exports = {
    SESSION_STATUS,
    Session,
    SessionManager,
    SessionTimeoutError,
};